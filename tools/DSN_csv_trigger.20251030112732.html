<!doctype html>
<html lang="en">
<meta charset="utf-8" />
<title>DSN CSV Export</title>
<meta name="viewport" content="width=device-width,initial-scale=1" />
<style>
  body{font-family:system-ui,-apple-system,Segoe UI,Roboto,Arial,sans-serif;margin:20px;line-height:1.45}
  .wrap{max-width:780px}
  h1{margin:0 0 .5rem 0}
  .muted{color:#666}
  .row{margin:1rem 0}
  .btn{display:inline-block;padding:.6rem 1rem;border:1px solid #ddd;border-radius:8px;text-decoration:none;cursor:pointer}
  .btn.disabled{opacity:.5;pointer-events:none}
  .ok{color:#0a6}
  .err{color:#b00}
  .bar{height:14px;background:#222;border-radius:7px;overflow:hidden;outline:2px solid #900}
  .bar>span{display:block;height:100%;width:0%;
            background:#ff1744;box-shadow:0 0 6px #ff1744,0 0 12px #ff1744;transition:width .45s ease}
  .done .bar>span{background:#18c37e;box-shadow:0 0 6px #18c37e,0 0 12px #18c37e}
  .hint{font-size:.9rem;color:#666}
</style>

<div class="wrap" id="wrap">
  <h1>DSN CSV Export</h1>
  <div class="muted" id="desc">Preparing‚Ä¶</div>

  <div class="row"><div class="bar"><span id="bar"></span></div></div>

  <div class="row">
    <a id="download" class="btn disabled" href="#">‚¨á Download CSV</a>
    <a id="viewlog" class="btn" target="_blank" rel="noopener" style="display:none;">ü™µ View log</a>
    <a id="retry" class="btn" href="#" style="display:none;">‚Üª Retry</a>
  </div>

  <div class="row muted" id="status">‚öôÔ∏è Working‚Ä¶</div>
  <div class="row hint" id="hint" style="display:none;"></div>
</div>

<script>
(() => {
  const GH_PAGES_BASE = "https://soazcomms.github.io";
  const GH_RAW_BASE   = "https://raw.githubusercontent.com/soazcomms/soazcomms.github.io/main";
  const WEBHOOK_URL   = "https://sound-kangaroo-unlikely.ngrok-free.app/DSN_csv";
  const CLEANUP_URL   = "https://sound-kangaroo-unlikely.ngrok-free.app/DSN_cleanup";

  const qs      = new URLSearchParams(location.search);
  const label   = (qs.get("label")||"").trim();
  const fromQ   = (qs.get("from") || "").trim();
  const toQ     = (qs.get("to")   || "").trim();
  const toYMD   = s => String(s).slice(0,10).replaceAll("/","-");
  const yFrom   = toYMD(fromQ), yTo = toYMD(toQ);
  const yFromC  = yFrom.replaceAll("-",""); const yToC = yTo.replaceAll("-","");
  const safeLabel = (label||"").replace(/[^\w.\-]+/g, "_");

  const wrapEl  = document.getElementById("wrap");
  const statusEl= document.getElementById("status");
  const barEl   = document.getElementById("bar");
  const dlEl    = document.getElementById("download");
  const logEl   = document.getElementById("viewlog");
  const retryEl = document.getElementById("retry");
  const descEl  = document.getElementById("desc");
  const hintEl  = document.getElementById("hint");

  descEl.textContent = `Label: ${label} ¬∑ Range: ${yFrom} ‚Üí ${yTo}`;
  dlEl.classList.add("disabled"); dlEl.href = "#";

  const bust = u => u + (u.includes("?") ? "&" : "?") + "bust=" + Date.now();
  async function getOk(u){ try{ const r=await fetch(bust(u),{method:"GET",cache:"no-store",redirect:"follow"}); return r.ok; }catch{ return false; } }

  async function forceDownloadFromUrl(srcUrl, filename, onStatus) {
    try {
      onStatus && onStatus("Preparing download‚Ä¶");
      const resp = await fetch(bust(srcUrl), { method:"GET", cache:"no-store", mode:"cors", redirect:"follow" });
      if (!resp.ok) throw new Error("HTTP " + resp.status);
      const blob = await resp.blob();
      const objectUrl = URL.createObjectURL(blob);
      const a = document.createElement("a");
      a.href = objectUrl; a.download = filename || "data.csv";
      document.body.appendChild(a); a.click();
      setTimeout(()=>{ URL.revokeObjectURL(objectUrl); a.remove(); onStatus && onStatus("‚úÖ CSV ready."); }, 250);
      return true;
    } catch (e) {
      onStatus && onStatus("‚ö†Ô∏è Download failed: " + (e && e.message ? e.message : e));
      return false;
    }
  }

  // progress ‚Üí 95%
  let pct=6, ticks=0, lastTs=0;
  barEl.style.width = pct + "%";
  const tTick=setInterval(()=>{ pct=Math.min(95,pct+1+Math.min(6,Math.floor(ticks/5))); barEl.style.width=pct+"%"; ticks++; }, 900);

  // start job
  fetch(WEBHOOK_URL,{method:"POST",headers:{"content-type":"application/json"},body:JSON.stringify({label,from:yFrom,to:yTo})})
    .then(()=>{ statusEl.textContent="Triggered‚Ä¶ generating CSV"; })
    .catch(()=>{ statusEl.textContent="Triggered (no response)"; });

  const statusRel = `status/status-${safeLabel}.json`;
  const rawStatus = `${GH_RAW_BASE}/${statusRel}`;
  const pagesStatus = `${GH_PAGES_BASE}/${statusRel}`;

  const expectedRel  = `DSNdata/${safeLabel}_${yFromC}_${yToC}.csv`;
  const rawGuessURL  = `${GH_RAW_BASE}/${expectedRel}`;
  const pagesGuessURL= `${GH_PAGES_BASE}/${expectedRel}`;

  async function getStatus() {
    try { const r=await fetch(bust(rawStatus),{cache:"no-store"}); if (r.ok) return await r.json(); } catch {}
    try { const r=await fetch(bust(pagesStatus),{cache:"no-store"}); if (r.ok) return await r.json(); } catch {}
    return null;
  }

  function wireDownload(finalUrl){
    const pretty = `${label}_${yFrom}_${yTo}.csv`;
    dlEl.classList.remove("disabled");
    dlEl.removeAttribute("href");
    dlEl.onclick = async (e)=>{
      e.preventDefault();
      const ok = await forceDownloadFromUrl(finalUrl, pretty, (msg)=>{ statusEl.textContent=msg; });
      if (ok) {
          // cleanup request
          statusEl.textContent = "üßπ Cleaning up‚Ä¶";
	  const cleanupBody = { label, from: yFrom, to: yTo };

	  fetch(CLEANUP_URL, {
	      method: "POST",
	      headers: { "content-type": "application/json" },
	      body: JSON.stringify(cleanupBody)
	  })
	  .then(r => r.json().then(j => ({ ok: r.ok, body: j })).catch(() => ({ ok: r.ok, body: {} })))
	  .then(async ({ ok, body }) => {
	      const rawUrl   = finalUrl.includes("raw.githubusercontent.com") ? finalUrl : finalUrl.replace(GH_PAGES_BASE, GH_RAW_BASE);
	      const pagesUrl = finalUrl.includes(GH_PAGES_BASE) ? finalUrl : finalUrl.replace(GH_RAW_BASE, GH_PAGES_BASE);

	      // If push failed, don‚Äôt spin forever
	      if (!ok || body.push_ok === false) {
		  statusEl.textContent = "‚ö†Ô∏è Cleanup push failed ‚Äî check git on server.";
		  return;
	      }

	      // Poll both RAW and Pages for disappearance (404)
	      const maxSec = 120;
	      for (let sec = 1; sec <= maxSec; sec++) {
		  const [r1, r2] = await Promise.allSettled([
		      fetch(rawUrl + (rawUrl.includes("?") ? "&" : "?") + "bust=" + Date.now(), { cache: "no-store", redirect: "follow" }),
		      fetch(pagesUrl + (pagesUrl.includes("?") ? "&" : "?") + "bust=" + Date.now(), { cache: "no-store", redirect: "follow" }),
		  ]);

		  const goneRaw   = r1.status === "fulfilled" && r1.value && r1.value.status === 404;
		  const gonePages = r2.status === "fulfilled" && r2.value && r2.value.status === 404;

		  if (goneRaw && gonePages) {
		      statusEl.textContent = "üßπ Cleaned up.";
		      return;
		  }
		  statusEl.textContent = `üßπ Cleaning up‚Ä¶ (${sec}s)`;
		  await new Promise(res => setTimeout(res, 1000));
	      }
	      statusEl.textContent = "‚ö†Ô∏è Cleanup pushed; CDN may still be serving cached file for a bit.";
	  })
	  .catch(() => {
	      statusEl.textContent = "‚ö†Ô∏è Cleanup request failed (network).";
	  });
      }
    };
  }

  function finish(finalUrl){
    clearInterval(tPoll); clearInterval(tTick);
    barEl.style.width = "100%"; document.getElementById("wrap").classList.add("done");
    statusEl.innerHTML = '<span class="ok">‚úÖ CSV ready.</span>';
    wireDownload(finalUrl);
    hintEl.style.display = "block";
    hintEl.textContent = "If the browser blocks the first attempt, click Download again.";
  }

  function fail(msg){
    clearInterval(tPoll); clearInterval(tTick);
    barEl.style.width = "100%";
    statusEl.innerHTML = `<span class="err">‚ùå Failed.</span> ${msg||""}`;
    retryEl.style.display="inline-block";
    retryEl.onclick=(e)=>{ e.preventDefault(); location.reload(); };
  }

  const tPoll = setInterval(async ()=>{
    if (await getOk(rawGuessURL)) { finish(rawGuessURL); return; }

    const data = await getStatus(); if (!data) return;
    data.note = ""; // hide backend chatter

    if (data.log) {
      const logAbs = /^https?:\/\//i.test(data.log) ? data.log : `${GH_PAGES_BASE}/${String(data.log).replace(/^\/+/,"")}`;
      logEl.href = bust(logAbs); logEl.style.display="inline-block";
    }

    if (data.timestamp && data.timestamp !== lastTs) {
      lastTs = data.timestamp; pct = Math.min(97, pct+2); barEl.style.width=pct+"%";
    }

    const rel = data.csv ? String(data.csv).replace(/^\/+/, "") : "";
    const pagesAbs = rel ? `${GH_PAGES_BASE}/${rel}` : "";
    const rawAbs   = rel ? `${GH_RAW_BASE}/${rel}`   : "";

    if (await getOk(rawAbs))   { finish(rawAbs);   return; }
    if (await getOk(pagesAbs)) { finish(pagesAbs); return; }

    const phase = String(data.phase||"").toLowerCase();
    if (phase === "error") { fail(data.status||""); return; }
    if (phase === "done" && (rawAbs || pagesAbs)) { finish(rawAbs || pagesAbs); return; }

    statusEl.textContent = "‚öôÔ∏è Working‚Ä¶";
  }, 900);
})();
</script>
</html>

<!-- STAMP: DSN_csv_trigger 20251030112732 -->
<div id="stamp" style="position:fixed;right:8px;bottom:8px;font:12px/1.2 monospace;color:#999;">STAMP 20251030112732</div>
