<!doctype html>
<html lang="en">
<meta charset="utf-8" />
<title>DSN CSV Export</title>
<meta name="viewport" content="width=device-width,initial-scale=1" />
<style>
  body{font-family:system-ui,-apple-system,Segoe UI,Roboto,Arial,sans-serif;margin:20px;line-height:1.45}
  .wrap{max-width:780px}
  h1{margin:0 0 .5rem 0}
  .muted{color:#666}
  .row{margin:1rem 0}
  .btn{display:inline-block;padding:.6rem 1rem;border:1px solid #ddd;border-radius:8px;text-decoration:none;cursor:pointer}
  .btn.disabled{opacity:.5;pointer-events:none}
  .ok{color:#0a6}
  .err{color:#b00}
  /* keep your existing bar look */
  .bar{height:14px;background:#222;border-radius:7px;overflow:hidden;outline:2px solid #900}
  .bar>span{display:block;height:100%;width:0%;
            background:#ff1744;box-shadow:0 0 6px #ff1744,0 0 12px #ff1744;transition:width .45s ease}
  .done .bar>span{background:#18c37e;box-shadow:0 0 6px #18c37e,0 0 12px #18c37e}
  .hint{font-size:.9rem;color:#666}
</style>

<div class="wrap" id="wrap">
  <h1>DSN CSV Export</h1>
  <div class="muted" id="desc">Preparing‚Ä¶</div>

  <div class="row"><div class="bar"><span id="bar"></span></div></div>

  <div class="row">
    <a id="download" class="btn disabled" href="#">‚¨á Download CSV</a>
    <a id="viewlog" class="btn disabled" target="_blank" rel="noopener" href="#">ü™µ View log</a>
    <a id="retry" class="btn" href="#" style="display:none;">‚Üª Retry</a>
  </div>

  <div class="row muted" id="status">‚öôÔ∏è Working‚Ä¶</div>
  <div class="row hint" id="hint" style="display:none;"></div>
</div>

<script>
(() => {
  // --- CONFIG ---
  const GH_PAGES_BASE = "https://soazcomms.github.io";
  const GH_RAW_BASE   = "https://raw.githubusercontent.com/soazcomms/soazcomms.github.io/main";
  const WEBHOOK_URL   = "https://sound-kangaroo-unlikely.ngrok-free.app/DSN_csv";
  const CLEANUP_URL   = "https://sound-kangaroo-unlikely.ngrok-free.app/DSN_cleanup";

  // --- Query / DOM ---
  const qs      = new URLSearchParams(location.search);
  const label   = (qs.get("label")||"").trim();
  const fromQ   = (qs.get("from") || "").trim();
  const toQ     = (qs.get("to")   || "").trim();

  const wrapEl  = document.getElementById("wrap");
  const statusEl= document.getElementById("status");
  const barEl   = document.getElementById("bar");
  const dlEl    = document.getElementById("download");
  const logEl   = document.getElementById("viewlog");
  const retryEl = document.getElementById("retry");
  const descEl  = document.getElementById("desc");
  const hintEl  = document.getElementById("hint");

  const toYMD = s => String(s).slice(0,10).replaceAll("/","-");
  const yFrom = toYMD(fromQ), yTo = toYMD(toQ);
  descEl.textContent = `Label: ${label} ¬∑ Range: ${yFrom} ‚Üí ${yTo}`;

  const yFromC = yFrom.replaceAll("-","");
  const yToC   = yTo.replaceAll("-","");
  const safeLabel = (label||"").replace(/[^\w.\-]+/g, "_");

  // --- helpers ---
  const bust = u => u + (u.includes("?") ? "&" : "?") + "bust=" + Date.now();
  const setDisabled = (a, dis=true) => {
    if (dis) { a.classList.add("disabled"); a.setAttribute("aria-disabled","true"); }
    else { a.classList.remove("disabled"); a.removeAttribute("aria-disabled"); }
  };
  const tryFetchOk = async (u, opts={}) => {
    try {
      const r = await fetch(bust(u), { ...opts, cache:"no-store", redirect:"follow" });
      if (!r.ok) return { ok:false, status:r.status };
      return { ok:true, status:r.status, resp:r };
    } catch (e) {
      return { ok:false, status:0 };
    }
  };
  const toAbs = (maybe, base) => {
    if (!maybe) return null;
    if (/^https?:\/\//i.test(maybe)) return maybe;
    return base.replace(/\/+$/,"") + "/" + String(maybe).replace(/^\/+/,"");
  };

  // --- show initial buttons disabled ---
  setDisabled(dlEl, true);
  setDisabled(logEl, true);

  // --- progress bar (unchanged visuals) ---
  let pct=6, ticks=0, lastTs=0;
  barEl.style.width = pct + "%";
  const tTick=setInterval(()=>{ pct=Math.min(95,pct+1+Math.min(6,Math.floor(ticks/5))); barEl.style.width=pct+"%"; ticks++; }, 900);

  // --- fire server job (idempotent) ---
  fetch(WEBHOOK_URL, {
    method: "POST",
    headers: {"content-type":"application/json"},
    body: JSON.stringify({ label, from: yFrom, to: yTo })
  }).then(()=>{ statusEl.textContent = "Triggered‚Ä¶ generating CSV"; })
    .catch(()=>{ statusEl.textContent = "Triggered (no response)"; });

  // --- status JSON paths (prefer RAW for freshness, then Pages) ---
  const statusRel = `status/status-${safeLabel}.json`;
  const statusRaw = `${GH_RAW_BASE}/${statusRel}`;
  const statusPg  = `${GH_PAGES_BASE}/${statusRel}`;

  // --- candidates we will attempt only on click (no prefetch) ---
  let CSV_CANDIDATES = []; // list of URLs to try
  let LOG_CANDIDATES = []; // list of URLs to try

  // --- CSV download handler (tries multiple candidates until one works) ---
  dlEl.onclick = async (e)=>{
    e.preventDefault();
    if (!CSV_CANDIDATES.length) return;

    statusEl.textContent = "Preparing download‚Ä¶";
    const pretty = `${safeLabel}_${yFrom}_${yTo}.csv`;

    // Attempt in order; on first 200, stream to Blob & download
    for (const u of CSV_CANDIDATES) {
      const { ok, resp } = await tryFetchOk(u, { method:"GET" });
      if (!ok) continue;
      const blob = await resp.blob();
      const objectUrl = URL.createObjectURL(blob);
      const a = document.createElement("a");
      a.href = objectUrl; a.download = pretty;
      document.body.appendChild(a); a.click();
      setTimeout(()=>{ URL.revokeObjectURL(objectUrl); a.remove(); }, 250);

      // Trigger cleanup (best-effort)
      statusEl.textContent = "üßπ Cleaning up‚Ä¶";
      fetch(CLEANUP_URL, {
        method:"POST",
        headers:{"content-type":"application/json"},
        body: JSON.stringify({ label, from: yFrom, to: yTo })
      }).catch(()=>{ /* ignore */ });

      statusEl.innerHTML = '<span class="ok">‚úÖ CSV downloaded.</span>';
      return;
    }
    statusEl.textContent = "‚ö†Ô∏è Download failed: HTTP 404";
  };

  // --- LOG handler (open first working candidate in a new tab) ---
  logEl.onclick = async (e)=>{
    e.preventDefault();
    if (!LOG_CANDIDATES.length) return;
    // Try candidates; open first working URL in a new tab without fetching contents (check with HEAD/GET then window.open)
    for (const u of LOG_CANDIDATES) {
      const { ok } = await tryFetchOk(u, { method:"GET" });
      if (ok) { window.open(bust(u), "_blank", "noopener"); return; }
    }
    statusEl.textContent = "‚ö†Ô∏è Log not available (404)";
  };

  // --- poll ONLY the status JSON, never the CSV/log (avoids CORS hangs) ---
  async function getStatus() {
    const hit = async (u) => {
      try { const r = await fetch(bust(u), { cache:"no-store" }); if (r.ok) return await r.json(); }
      catch {}
      return null;
    };
    return (await hit(statusRaw)) || (await hit(statusPg));
  }

  const tPoll = setInterval(async ()=>{
    const data = await getStatus();
    if (!data) { statusEl.textContent = "‚öôÔ∏è Working‚Ä¶"; return; }

    // keep your bar feeling alive when timestamp changes
    if (data.timestamp && data.timestamp !== lastTs) {
      lastTs = data.timestamp; pct = Math.min(97, pct+2); barEl.style.width = pct + "%";
    }

    // Build candidates once we have something meaningful
    // CSV list (no prefetch): data.csv_raw, data.csv (Pages/abs), expected RAW/Pages guesses
    if (!CSV_CANDIDATES.length) {
      const relExpected = `DSNdata/${safeLabel}_${yFromC}_${yToC}.csv`;
      const guessRAW    = `${GH_RAW_BASE}/${relExpected}`;
      const guessPages  = `${GH_PAGES_BASE}/${relExpected}`;
      const dRaw        = toAbs(data.csv_raw, GH_RAW_BASE);
      const dPages      = toAbs(data.csv, GH_PAGES_BASE);

      const list = [];
      if (dRaw)   list.push(dRaw);
      if (dPages) list.push(dPages);
      list.push(guessRAW, guessPages);

      // de-dup + URL encode each
      CSV_CANDIDATES = Array.from(new Set(list.filter(Boolean).map(u => encodeURI(u))));
    }

    // LOG list (no prefetch)
    if (!LOG_CANDIDATES.length) {
      const logRaw   = toAbs(data.log_raw, GH_RAW_BASE);
      const logPages = toAbs(data.log, GH_PAGES_BASE);
      const guessRel = `logs/csv-${safeLabel}-${yFromC}-${yToC}.log`;
      const guessRAW = `${GH_RAW_BASE}/${guessRel}`;
      const guessPg  = `${GH_PAGES_BASE}/${guessRel}`;

      const list = [];
      if (logRaw)   list.push(logRaw);
      if (logPages) list.push(logPages);
      list.push(guessRAW, guessPg);

      LOG_CANDIDATES = Array.from(new Set(list.filter(Boolean).map(u => encodeURI(u))));
      // Make the button visible once we have at least a candidate
      setDisabled(logEl, LOG_CANDIDATES.length === 0);
    }

    const phase = String(data.phase||"").toLowerCase();

    if (phase === "done") {
      clearInterval(tPoll); clearInterval(tTick);
      barEl.style.width = "100%"; wrapEl.classList.add("done");
      statusEl.innerHTML = '<span class="ok">‚úÖ CSV ready.</span>';
      setDisabled(dlEl, false);
      setDisabled(logEl, LOG_CANDIDATES.length === 0);
      hintEl.style.display = "block";
      hintEl.textContent = "Tip: If your browser blocks the first attempt, click Download again.";
      return;
    }

    if (phase === "error") {
      clearInterval(tPoll); clearInterval(tTick);
      barEl.style.width = "100%";
      statusEl.innerHTML = `<span class="err">‚ùå Failed.</span>`;
      retryEl.style.display="inline-block";
      retryEl.onclick=(e)=>{ e.preventDefault(); location.reload(); };
      return;
    }

    // neutral status during build
    statusEl.textContent = "‚öôÔ∏è Working‚Ä¶";
  }, 900);
})();
</script>
</html>

<!-- STAMP: DSN_csv_trigger 20251030125743 -->
<div id="stamp" style="position:fixed;right:8px;bottom:8px;font:12px/1.2 monospace;color:#999;">STAMP 20251030125743</div>
