<!doctype html>
<html lang="en">
<meta charset="utf-8" />
<title>DSN CSV Export</title>
<meta name="viewport" content="width=device-width,initial-scale=1" />
<style>
  body{font-family:system-ui,-apple-system,Segoe UI,Roboto,Arial,sans-serif;margin:20px;line-height:1.45}
  .wrap{max-width:780px}
  h1{margin:0 0 .5rem 0}
  .muted{color:#666}
  .row{margin:1rem 0}
  .btn{display:inline-block;padding:.6rem 1rem;border:1px solid #ddd;border-radius:8px;text-decoration:none;cursor:pointer}
  .btn.disabled{opacity:.5;pointer-events:none}
  .ok{color:#0a6}
  .err{color:#b00}
  /* keep your existing bar look/size/colors */
  .bar{height:14px;background:#222;border-radius:7px;overflow:hidden;outline:2px solid #900}
  .bar>span{display:block;height:100%;width:0%;
            background:#ff1744;box-shadow:0 0 6px #ff1744,0 0 12px #ff1744;transition:width .45s ease}
  .done .bar>span{background:#18c37e;box-shadow:0 0 6px #18c37e,0 0 12px #18c37e}
  .hint{font-size:.9rem;color:#666}
</style>

<div class="wrap" id="wrap">
  <h1>DSN CSV Export</h1>
  <div class="muted" id="desc">Preparing‚Ä¶</div>

  <div class="row"><div class="bar"><span id="bar"></span></div></div>

  <div class="row">
    <a id="download" class="btn disabled" href="#">‚¨á Download CSV</a>
    <a id="viewlog" class="btn disabled" target="_blank" rel="noopener" href="#">ü™µ View log</a>
    <a id="retry" class="btn" href="#" style="display:none;">‚Üª Retry</a>
  </div>

  <div class="row muted" id="status">‚öôÔ∏è Working‚Ä¶</div>
  <div class="row hint" id="hint" style="display:none;"></div>
</div>

<script>
(() => {
  // --- constants (unchanged bases) ---
  const GH_PAGES_BASE = "https://soazcomms.github.io";
  const GH_RAW_BASE   = "https://raw.githubusercontent.com/soazcomms/soazcomms.github.io/main";
  const WEBHOOK_URL   = "https://sound-kangaroo-unlikely.ngrok-free.app/DSN_csv";
  const FORCE_URL     = "https://sound-kangaroo-unlikely.ngrok-free.app/DSN_force";
  const CLEANUP_URL   = "https://sound-kangaroo-unlikely.ngrok-free.app/DSN_cleanup";

  // Timers: when to probe CSV, when to force, when to give up
  const FALLBACK_AFTER_MS = 12000;  // start probing for CSV after 12s
  const PROBE_EVERY_MS    = 4000;   // probe cadence
  const FORCE_AFTER_MS    = 20000;  // call /DSN_force once at 20s if still not ready
  const MAX_TOTAL_MS      = 60000;  // hard fail-out at 60s (no more hanging)

  // --- qs / dom ---
  const qs      = new URLSearchParams(location.search);
  const label   = (qs.get("label")||"").trim();
  const fromQ   = (qs.get("from") || "").trim();
  const toQ     = (qs.get("to")   || "").trim();

  const wrapEl  = document.getElementById("wrap");
  const statusEl= document.getElementById("status");
  const barEl   = document.getElementById("bar");
  const dlEl    = document.getElementById("download");
  const logEl   = document.getElementById("viewlog");
  const retryEl = document.getElementById("retry");
  const descEl  = document.getElementById("desc");
  const hintEl  = document.getElementById("hint");

  const toYMD = s => String(s).slice(0,10).replaceAll("/","-");
  const yFrom = toYMD(fromQ), yTo = toYMD(toQ);
  descEl.textContent = `Label: ${label} ¬∑ Range: ${yFrom} ‚Üí ${yTo}`;

  const yFromC = yFrom.replaceAll("-","");
  const yToC   = yTo.replaceAll("-","");
  const safeLabel = (label||"").replace(/[^\w.\-]+/g, "_");

  // progress bar (unchanged visuals)
  let pct=8, ticks=0, lastTs=0, ready=false, forced=false, failed=false;
  barEl.style.width = pct + "%";
  const tTick=setInterval(()=>{ pct=Math.min(95,pct+1+Math.min(6,Math.floor(ticks/5))); barEl.style.width=pct+"%"; ticks++; }, 900);

  // helpers
  const bust = u => u + (u.includes("?") ? "&" : "?") + "bust=" + Date.now();
  const setDisabled = (a, dis=true) => {
    if (dis) { a.classList.add("disabled"); a.setAttribute("aria-disabled","true"); }
    else { a.classList.remove("disabled"); a.removeAttribute("aria-disabled"); }
  };
  const toAbs = (maybe, base) => {
    if (!maybe) return null;
    if (/^https?:\/\//i.test(maybe)) return maybe;
    return base.replace(/\/+$/,"") + "/" + String(maybe).replace(/^\/+/,"");
  };
  const postJSON = (url, body) =>
    fetch(url, { method:"POST", headers:{"content-type":"application/json"}, body: JSON.stringify(body||{}) });

  // cleanup after download (unchanged idea)
  async function postCleanup(csvRelPath) {
    try {
      const payload = JSON.stringify({ csv: String(csvRelPath||"").replace(/^\/+/, "") });
      const blob = new Blob([payload], { type: "application/json" });
      if (navigator.sendBeacon && navigator.sendBeacon(CLEANUP_URL, blob)) return;
      await fetch(CLEANUP_URL, { method:"POST", headers:{ "Content-Type":"application/json" }, body: payload });
    } catch {}
  }
  function triggerDownloadAndCleanup(finalUrl, csvRelPath, prettyName) {
    const a = document.createElement("a");
    a.href = finalUrl;
    a.download = prettyName || "";
    document.body.appendChild(a);
    a.click();
    a.remove();
    setTimeout(() => { postCleanup(csvRelPath); }, 1200);
  }

  // fast HEAD probe (fallback when status won't flip). Returns first URL that responds 200.
  async function firstReachable(urls){
    for (const u of urls) {
      try {
        const r = await fetch(bust(u), {method:"HEAD", cache:"no-store", redirect:"follow"});
        if (r && (r.ok || (r.type==="opaqueredirect"))) return u;
      } catch {}
    }
    return null;
  }

  // kick server job (idempotent)
  postJSON(WEBHOOK_URL, { label, from: yFrom, to: yTo })
    .then(()=>{ statusEl.textContent = "‚öôÔ∏è Working‚Ä¶"; })
    .catch(()=>{ /* silent */ });

  // status json (RAW first for freshness; fallback to Pages)
  const statusRel = `status/status-${safeLabel}.json`;
  const rawStatus = `${GH_RAW_BASE}/${statusRel}`;
  const pgStatus  = `${GH_PAGES_BASE}/${statusRel}`;

  async function getStatus() {
    try { const r = await fetch(bust(rawStatus), { cache:"no-store" }); if (r.ok) return await r.json(); } catch {}
    try { const r = await fetch(bust(pgStatus),  { cache:"no-store" }); if (r.ok) return await r.json(); } catch {}
    return null;
  }

  function enableLog(url) {
    if (!url) return;
    logEl.href = bust(url);
    setDisabled(logEl, false);
  }

  function enableDownload(urls, csvRelPath) {
    if (!urls || !urls.length) return;
    setDisabled(dlEl, false);
    dlEl.onclick = async (e)=>{
      e.preventDefault();
      statusEl.textContent = "Preparing download‚Ä¶";
      const pretty = `${safeLabel}_${yFrom}_${yTo}.csv`;

      for (const u of urls) {
        try {
          const r = await fetch(bust(u), { method:"GET", cache:"no-store", redirect:"follow" });
          if (!r.ok) continue;
          const blob = await r.blob();
          const url = URL.createObjectURL(blob);
          triggerDownloadAndCleanup(url, csvRelPath, pretty);
          wrapEl.classList.add("done"); barEl.style.width="100%";
          statusEl.innerHTML = '<span class="ok">‚úÖ CSV downloaded.</span>';
          setTimeout(()=> URL.revokeObjectURL(url), 1500);
          return;
        } catch {}
      }
      statusEl.innerHTML = `‚ö†Ô∏è Download failed: HTTP 404`;
    };
  }

  function csvCandidatesFrom(data){
    const rel = data && data.csv
      ? String(data.csv).replace(/^\/+/, "")
      : `DSNdata/${safeLabel}_${yFromC}_${yToC}.csv`;
    const cands = [];
    if (data && data.csv_raw) cands.push(String(data.csv_raw));
    if (data && data.csv)     cands.push(toAbs(data.csv, GH_PAGES_BASE));
    const guessRel = `DSNdata/${safeLabel}_${yFromC}_${yToC}.csv`;
    cands.push(`${GH_RAW_BASE}/${guessRel}`);
    cands.push(`${GH_PAGES_BASE}/${guessRel}`);
    return { rel, urls: Array.from(new Set(cands.filter(Boolean))) };
  }
  function logCandidatesFrom(data){
    const cands = [];
    if (data && data.log_raw) cands.push(String(data.log_raw));
    if (data && data.log)     cands.push(toAbs(data.log, GH_PAGES_BASE));
    const guessLog = `logs/csv-${safeLabel}-${yFromC}-${yToC}.log`;
    cands.push(`${GH_RAW_BASE}/${guessLog}`);
    cands.push(`${GH_PAGES_BASE}/${guessLog}`);
    return Array.from(new Set(cands.filter(Boolean)));
  }

  // polling + fallback + force + final cap
  let startedAt = Date.now();
  let lastProbe = 0;
  let forcedOnce = false;

  const tPoll = setInterval(async ()=>{
    if (ready || failed) return;

    const elapsed = Date.now() - startedAt;

    // Primary: read status json
    const data = await getStatus();

    if (data && data.timestamp && data.timestamp !== lastTs) {
      lastTs = data.timestamp; pct = Math.min(97, pct+2); barEl.style.width = pct + "%";
    }

    const phase = String(data && data.phase || "").toLowerCase();

    if (phase === "error") {
      clearInterval(tPoll); clearInterval(tTick);
      barEl.style.width = "100%";
      statusEl.innerHTML = `<span class="err">‚ùå Failed.</span> ${data.status||""}`;
      retryEl.style.display="inline-block";
      retryEl.onclick=(e)=>{ e.preventDefault(); location.reload(); };
      failed = true;
      return;
    }

    // If status says done ‚Üí arm immediately
    if (phase === "done") {
      clearInterval(tPoll); clearInterval(tTick);
      wrapEl.classList.add("done"); barEl.style.width = "100%";
      statusEl.innerHTML = '<span class="ok">‚úÖ CSV ready.</span>';
      hintEl.style.display = "block";
      hintEl.textContent = "If the browser blocks the first attempt, click Download again.";
      const cc = csvCandidatesFrom(data);
      enableDownload(cc.urls, cc.rel);
      const logC = logCandidatesFrom(data);
      if (logC.length) enableLog(logC[0]);
      ready = true;
      return;
    }

    // Fallback: after a bit, HEAD-probe CSV existence even if status never flips
    if (elapsed >= FALLBACK_AFTER_MS && (Date.now() - lastProbe) >= PROBE_EVERY_MS) {
      lastProbe = Date.now();
      const cc = csvCandidatesFrom(data || {});
      const found = await firstReachable(cc.urls);
      if (found) {
        clearInterval(tPoll); clearInterval(tTick);
        wrapEl.classList.add("done"); barEl.style.width = "100%";
        statusEl.innerHTML = '<span class="ok">‚úÖ CSV ready.</span>';
        hintEl.style.display = "block";
        hintEl.textContent = "If the browser blocks the first attempt, click Download again.";
        enableDownload([found, ...cc.urls.filter(u=>u!==found)], cc.rel);
        const logC = logCandidatesFrom(data || {});
        const logFound = await firstReachable(logC);
        if (logFound) enableLog(logFound); else if (logC.length) enableLog(logC[0]);
        ready = true;
        return;
      }
    }

    // HARD OVERRIDE once at FORCE_AFTER_MS
    if (!forcedOnce && elapsed >= FORCE_AFTER_MS) {
      forcedOnce = true;
      // silent (no noisy text): ask webhook to finish/rescue
      postJSON(FORCE_URL, { label, from: yFrom, to: yTo }).catch(()=>{});
    }

    // FINAL CAP: if nothing worked by MAX_TOTAL_MS ‚Üí fail, don't hang
    if (elapsed >= MAX_TOTAL_MS) {
      clearInterval(tPoll); clearInterval(tTick);
      barEl.style.width = "100%";
      statusEl.innerHTML = `<span class="err">‚ùå File not found where expected.</span>`;
      retryEl.style.display="inline-block";
      retryEl.onclick=(e)=>{ e.preventDefault(); location.reload(); };
      failed = true;
      return;
    }

    statusEl.textContent = "‚öôÔ∏è Working‚Ä¶";
  }, 900);
})();
</script>
</html>

<!-- STAMP: DSN_csv_trigger 20251030161659 -->
<div id="stamp" style="position:fixed;right:8px;bottom:8px;font:12px/1.2 monospace;color:#999;">STAMP 20251030161659</div>
