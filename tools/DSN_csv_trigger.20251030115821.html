<!doctype html>
<html lang="en">
<meta charset="utf-8" />
<title>DSN CSV Export</title>
<meta name="viewport" content="width=device-width,initial-scale=1" />
<style>
  body{font-family:system-ui,-apple-system,Segoe UI,Roboto,Arial,sans-serif;margin:20px;line-height:1.45}
  .wrap{max-width:780px}
  h1{margin:0 0 .5rem 0}
  .muted{color:#666}
  .row{margin:1rem 0}
  .btn{display:inline-block;padding:.6rem 1rem;border:1px solid #ddd;border-radius:8px;text-decoration:none;cursor:pointer}
  .btn.disabled{opacity:.5;pointer-events:none}
  .ok{color:#0a6}
  .err{color:#b00}
  .bar{height:14px;background:#222;border-radius:7px;overflow:hidden;outline:2px solid #900}
  .bar>span{display:block;height:100%;width:0%;
            background:#ff1744;box-shadow:0 0 6px #ff1744,0 0 12px #ff1744;transition:width .45s ease}
  .done .bar>span{background:#18c37e;box-shadow:0 0 6px #18c37e,0 0 12px #18c37e}
  .hint{font-size:.9rem;color:#666}
</style>

<div class="wrap" id="wrap">
  <h1>DSN CSV Export</h1>
  <div class="muted" id="desc">Preparing‚Ä¶</div>

  <div class="row"><div class="bar"><span id="bar"></span></div></div>

  <div class="row">
    <a id="download" class="btn disabled" href="#">‚¨á Download CSV</a>
    <a id="viewlog" class="btn" target="_blank" rel="noopener" style="display:none;">ü™µ View log</a>
    <a id="retry" class="btn" href="#" style="display:none;">‚Üª Retry</a>
  </div>

  <div class="row muted" id="status">‚öôÔ∏è Working‚Ä¶</div>
  <div class="row hint" id="hint" style="display:none;"></div>
</div>

<script>
(() => {
  const GH_PAGES_BASE = "https://soazcomms.github.io";
  const GH_RAW_BASE   = "https://raw.githubusercontent.com/soazcomms/soazcomms.github.io/main";
  const WEBHOOK_URL   = "https://sound-kangaroo-unlikely.ngrok-free.app/DSN_csv";
  const CLEANUP_URL   = "https://sound-kangaroo-unlikely.ngrok-free.app/DSN_cleanup";

  const qs      = new URLSearchParams(location.search);
  const label   = (qs.get("label")||"").trim();
  const fromQ   = (qs.get("from") || "").trim();
  const toQ     = (qs.get("to")   || "").trim();
  const toYMD   = s => String(s).slice(0,10).replaceAll("/","-");
  const yFrom   = toYMD(fromQ), yTo = toYMD(toQ);
  const yFromC  = yFrom.replaceAll("-",""); const yToC = yTo.replaceAll("-","");
  const safeLabel = (label||"").replace(/[^\w.\-]+/g, "_");

  const wrapEl  = document.getElementById("wrap");
  const statusEl= document.getElementById("status");
  const barEl   = document.getElementById("bar");
  const dlEl    = document.getElementById("download");
  const logEl   = document.getElementById("viewlog");
  const retryEl = document.getElementById("retry");
  const descEl  = document.getElementById("desc");
  const hintEl  = document.getElementById("hint");

  descEl.textContent = `Label: ${label} ¬∑ Range: ${yFrom} ‚Üí ${yTo}`;
  dlEl.classList.add("disabled"); dlEl.href = "#";

  const bust = u => u + (u.includes("?") ? "&" : "?") + "bust=" + Date.now();

  async function fetchOK(u){
    try{
      const r = await fetch(bust(u), { method:"GET", cache:"no-store", redirect:"follow" });
      return r.ok ? r : null;
    }catch{ return null; }
  }
  async function firstReachable(urls){
    for (const u of urls){
      const r = await fetchOK(u);
      if (r) return { url:u, resp:r };
    }
    return null;
  }

  // Robust download that tries multiple URLs (RAW ‚Üí Pages fallback)
  async function forceDownload(urls, filename){
    const tried = [];
    for (const u of urls){
      tried.push(u);
      try{
        statusEl.textContent = "Preparing download‚Ä¶";
        const r = await fetch(bust(u), { method:"GET", cache:"no-store", redirect:"follow" });
        if (!r.ok) { continue; }              // try next candidate
        const blob = await r.blob();
        const objectUrl = URL.createObjectURL(blob);
        const a = document.createElement("a");
        a.href = objectUrl; a.download = filename || "data.csv";
        document.body.appendChild(a); a.click();
        setTimeout(()=>{ URL.revokeObjectURL(objectUrl); a.remove(); statusEl.textContent = "‚úÖ CSV ready."; }, 250);
        return true;
      }catch(_e){}
    }
    statusEl.textContent = "‚ö†Ô∏è Download failed: HTTP 404";
    return false;
  }

  // progress ‚Üí 95%
  let pct=6, ticks=0, lastTs=0;
  barEl.style.width = pct + "%";
  const tTick=setInterval(()=>{ pct=Math.min(95,pct+1+Math.min(6,Math.floor(ticks/5))); barEl.style.width=pct+"%"; ticks++; }, 900);

  // start job
  fetch(WEBHOOK_URL,{method:"POST",headers:{"content-type":"application/json"},body:JSON.stringify({label,from:yFrom,to:yTo})})
    .then(()=>{ statusEl.textContent="Triggered‚Ä¶ generating CSV"; })
    .catch(()=>{ statusEl.textContent="Triggered (no response)"; });

  // Paths we expect
  const statusRel = `status/status-${safeLabel}.json`;
  const rawStatus   = `${GH_RAW_BASE}/${statusRel}`;
  const pagesStatus = `${GH_PAGES_BASE}/${statusRel}`;

  const expectedRel   = `DSNdata/${safeLabel}_${yFromC}_${yToC}.csv`;
  const rawGuessCSV   = `${GH_RAW_BASE}/${expectedRel}`;
  const pagesGuessCSV = `${GH_PAGES_BASE}/${expectedRel}`;

  // Try status (prefer RAW, then Pages)
  async function getStatus() {
    try { const r=await fetch(bust(rawStatus),  {cache:"no-store"}); if (r.ok) return await r.json(); } catch {}
    try { const r=await fetch(bust(pagesStatus),{cache:"no-store"}); if (r.ok) return await r.json(); } catch {}
    return null;
  }

  // Wire ‚ÄúDownload‚Äù button once we know at least one working URL
  function wireDownload(finalRaw, finalPages){
    const pretty = `${label}_${yFrom}_${yTo}.csv`;
    dlEl.classList.remove("disabled");
    dlEl.removeAttribute("href");
    dlEl.onclick = async (e)=>{
      e.preventDefault();
      // Try RAW then Pages (or vice versa if RAW missing)
      const urls = [finalRaw, finalPages].filter(Boolean);
      const ok = await forceDownload(urls, pretty);
      if (!ok) return;

      // After successful download, request cleanup once.
      statusEl.textContent = "üßπ Cleaning up‚Ä¶";
      const cleanupBody = { label, from: yFrom, to: yTo };
      fetch(CLEANUP_URL, {
        method: "POST",
        headers: { "content-type": "application/json" },
        body: JSON.stringify(cleanupBody)
      })
      .then(r => r.json().then(j => ({ ok: r.ok, body: j })).catch(() => ({ ok: r.ok, body: {} })))
      .then(async ({ ok, body }) => {
        if (!ok || body.push_ok === false) {
          statusEl.textContent = "‚ö†Ô∏è Cleanup push failed ‚Äî check git on server.";
          return;
        }
        const rawU   = finalRaw   || (finalPages ? finalPages.replace(GH_PAGES_BASE, GH_RAW_BASE) : "");
        const pagesU = finalPages || (finalRaw   ? finalRaw.replace(GH_RAW_BASE, GH_PAGES_BASE) : "");
        const maxSec = 120;
        for (let sec = 1; sec <= maxSec; sec++){
          const [r1, r2] = await Promise.allSettled([
            fetch(bust(rawU),   { cache:"no-store", redirect:"follow" }),
            fetch(bust(pagesU), { cache:"no-store", redirect:"follow" }),
          ]);
          const goneRaw   = r1.status==="fulfilled" && r1.value && r1.value.status===404;
          const gonePages = r2.status==="fulfilled" && r2.value && r2.value.status===404;
          if (goneRaw && gonePages) { statusEl.textContent = "üßπ Cleaned up."; return; }
          statusEl.textContent = `üßπ Cleaning up‚Ä¶ (${sec}s)`;
          await new Promise(res=>setTimeout(res,1000));
        }
        statusEl.textContent = "‚ö†Ô∏è Cleanup pushed; CDN may still be serving cached file for a bit.";
      })
      .catch(() => { statusEl.textContent = "‚ö†Ô∏è Cleanup request failed (network)."; });
    };
  }

  function finish(finalRaw, finalPages){
    clearInterval(tPoll); clearInterval(tTick);
    barEl.style.width = "100%"; document.getElementById("wrap").classList.add("done");
    statusEl.innerHTML = '<span class="ok">‚úÖ CSV ready.</span>';
    wireDownload(finalRaw, finalPages);
    hintEl.style.display = "block";
    hintEl.textContent = "If the browser blocks the first attempt, click Download again.";
  }

  function fail(msg){
    clearInterval(tPoll); clearInterval(tTick);
    barEl.style.width = "100%";
    statusEl.innerHTML = `<span class="err">‚ùå Failed.</span> ${msg||""}`;
    retryEl.style.display="inline-block";
    retryEl.onclick=(e)=>{ e.preventDefault(); location.reload(); };
  }

  // Try to resolve a usable log URL (log_raw ‚Üí log ‚Üí heuristic guess; RAW first, then Pages)
  async function resolveLogUrl(data){
    const hyphenFrom = yFromC; // already compact (YYYYMMDD)
    const hyphenTo   = yToC;
    const guess = `logs/csv-${safeLabel}-${hyphenFrom}-${hyphenTo}.log`;

    const candidates = [];
    if (data && data.log_raw) candidates.push(String(data.log_raw));
    if (data && data.log){
      const l = String(data.log).replace(/^\/+/, "");
      candidates.push(/^https?:\/\//i.test(l) ? l : `${GH_RAW_BASE}/${l}`);
      candidates.push(/^https?:\/\//i.test(l) ? l : `${GH_PAGES_BASE}/${l}`);
    }
    // Heuristic guess (RAW then Pages)
    candidates.push(`${GH_RAW_BASE}/${guess}`);
    candidates.push(`${GH_PAGES_BASE}/${guess}`);

    const hit = await firstReachable(candidates);
    return hit ? hit.url : null;
  }

  const tPoll = setInterval(async ()=>{
    // Quick early hit: try RAW-guess directly
    const early = await fetchOK(rawGuessCSV);
    if (early) { finish(rawGuessCSV, pagesGuessCSV); return; }

    const data = await getStatus(); if (!data) return;
    data.note = ""; // hide backend chatter

    // Show log asap
    (async () => {
      const logUrl = await resolveLogUrl(data);
      if (logUrl){ logEl.href = bust(logUrl); logEl.style.display = "inline-block"; }
    })();

    if (data.timestamp && data.timestamp !== lastTs) {
      lastTs = data.timestamp; pct = Math.min(97, pct+2); barEl.style.width=pct+"%";
    }

    // CSV locations from status (prefer explicit csv_raw if present)
    const rel = data.csv ? String(data.csv).replace(/^\/+/, "") : "";
    const explicitRaw   = data.csv_raw ? String(data.csv_raw) : "";
    const pagesAbs = rel ? `${GH_PAGES_BASE}/${rel}` : "";
    const rawAbs   = explicitRaw || (rel ? `${GH_RAW_BASE}/${rel}` : "");

    // Choose first reachable of RAW/Pages, but also accept ‚Äúdone‚Äù w/out probe
    const hit = await firstReachable([rawAbs, pagesAbs].filter(Boolean));
    if (hit) { finish(rawAbs || "", pagesAbs || ""); return; }

    const phase = String(data.phase||"").toLowerCase();
    if (phase === "error") { fail(data.status||""); return; }
    if (phase === "done"  && (rawAbs || pagesAbs)) { finish(rawAbs || "", pagesAbs || ""); return; }

    statusEl.textContent = "‚öôÔ∏è Working‚Ä¶";
  }, 900);
})();
</script>
</html>

<!-- STAMP: DSN_csv_trigger 20251030115821 -->
<div id="stamp" style="position:fixed;right:8px;bottom:8px;font:12px/1.2 monospace;color:#999;">STAMP 20251030115821</div>
