<!doctype html>
<html lang="en">
<meta charset="utf-8" />
<title>DSN CSV Export V.04</title>
<meta name="viewport" content="width=device-width,initial-scale=1" />
<style>
  body{font-family:system-ui,-apple-system,Segoe UI,Roboto,Arial,sans-serif;margin:20px;line-height:1.45}
  .wrap{max-width:780px}
  h1{margin:0 0 .5rem 0}
  .muted{color:#666}
  .row{margin:1rem 0}
  .btn{display:inline-block;padding:.6rem 1rem;border:1px solid #ddd;border-radius:8px;text-decoration:none;cursor:pointer}
  .btn.disabled{opacity:.5;pointer-events:none}
  .ok{color:#0a6}
  .err{color:#b00}
  .hint{font-size:.9rem;color:#666}
  /* progress bar (keep look) */
  .progress-wrap { width:min(720px,90vw); margin:.75rem 0 .25rem; text-align:center; }
  .progress { width:50%; margin:0 auto; height:12px; background:#edf2f7; border-radius:999px; overflow:hidden; box-shadow:inset 0 0 0 1px #e2e8f0; }
  .legend { width:50%; margin:.35rem auto 0; display:flex; justify-content:space-between; font-size:.85rem; color:#555; }
  #barwrap{
      height:10px;
      width:50%;
      background:var(--barbg);
      border-radius:999px;
      overflow:hidden;
      margin:12px 0 4px 0;
      box-shadow:inset 0 0 0 1px #e2e8f0;
      display:block;              /* ensure not inline */
      margin-left:0;              /* explicit left alignment */
      margin-right:auto;          /* push right side open */
  }
  #bar{
      height:100%;
      width:0%;
      background:linear-gradient(90deg,#69c,#38bdf8 40%,#22c55e 75%,#16a34a 100%);
      transition:width .5s ease
  }
  .bar.timeout {
      background:linear-gradient(90deg,#f59e0b,#ef4444); }
</style>

<div class="wrap" id="wrap">
  <h1>DSN CSV Export V.04</h1>
  <div id="headerText" class="muted">Preparing‚Ä¶</div>

  <!-- Progress bar + timer -->
  <div class="progress-wrap" aria-label="Progress toward timeout window">
    <div class="progress"><div id="bar" class="bar" role="progressbar" aria-valuemin="0" aria-valuemax="100" aria-valuenow="0"></div></div>
    <div class="legend"><span id="leg-left" class="muted">0:00</span><span id="leg-right" class="muted">Timeout in 7:00</span></div>
  </div>

  <div class="row">
    <a id="download" class="btn disabled" href="#">‚¨á Download CSV</a>
    <a id="viewlog" class="btn disabled" target="_blank" rel="noopener" href="#">ü™µ View LOG</a>
    <a id="retry"   class="btn" href="#" style="display:none;">‚Üª Retry</a>
    <button id="exitBtn" class="btn" type="button" onclick="return closeTab(event)">üîô Exit</button>
  </div>

  <div class="row muted" id="status">‚öôÔ∏è Working‚Ä¶</div>
  <div class="row hint"   id="hint" style="display:none;"></div>
</div>

<script>
function closeTab(e){
  if (e) e.preventDefault();      // block any default action
  try {                           // try to close if allowed
    window.close();
    return false;
  } catch (_) {}

  // Fallbacks when the browser blocks close()
  if (document.referrer) { location.replace(document.referrer); return false; }
  if (history.length > 1) { history.back(); return false; }
  location.replace('https://soazcomms.grafana.net/');
  return false;
}
(async function(){

  /* ===== config ===== */
  const GH_PAGES_BASE = "https://soazcomms.github.io";
  const GH_RAW_BASE   = "https://raw.githubusercontent.com/soazcomms/soazcomms.github.io/main";
  const WEBHOOK_BASE  = "https://sound-kangaroo-unlikely.ngrok-free.app";  // ngrok
  const WEBHOOK_URL   = WEBHOOK_BASE + "/csv_only";
  const CLEANUP_URL   = WEBHOOK_BASE + "/DSN_cleanup";
  const DEBUG_URL     = WEBHOOK_BASE + "/DSN_debug";
  if (typeof window.DEBUG_FLAG === "undefined") window.DEBUG_FLAG = true;

  /* ===== DOM ===== */
  const headerEl = document.getElementById("headerText");
  const statusEl = document.getElementById("status");
  const barEl    = document.getElementById("bar");
  const legL     = document.getElementById("leg-left");
  const legR     = document.getElementById("leg-right");
  const dlEl     = document.getElementById("download");
  const logEl    = document.getElementById("viewlog");
  const retryEl  = document.getElementById("retry");
  const hintEl   = document.getElementById("hint");

  /* ===== time + progress ===== */
  const POLL_INTERVAL_MS = 900;
  const TIMEOUT_MS_INIT  = 7 * 60_000; // 7 minutes
  let   EXTRA_MS         = 0;
  const startedAt        = Date.now();
  function mmss(ms){ const s=Math.max(0,Math.floor(ms/1000)); return Math.floor(s/60)+":"+String(s%60).padStart(2,"0"); }
  function tick(timedOut){
    const elapsed = Date.now()-startedAt, total = TIMEOUT_MS_INIT + EXTRA_MS;
    const pct = Math.max(3, Math.min(100, Math.floor(elapsed/total*100)));
    barEl.style.width = pct + "%";
    barEl.setAttribute("aria-valuenow", String(pct));
    if (timedOut) barEl.classList.add("timeout"); else barEl.classList.remove("timeout");
    legL.textContent = mmss(elapsed);
    legR.textContent = timedOut ? "Waiting‚Ä¶" : ("Timeout in " + mmss(Math.max(0, total - elapsed)));
  }

  /* ===== inputs ===== */
  const qs    = new URLSearchParams(location.search);
  const label = (qs.get("label")||"").trim();
  const fromQ = (qs.get("from") ||"").trim();
  const toQ   = (qs.get("to")   ||"").trim();
  const DATE_RE = /^\d{4}-\d{2}-\d{2}$/;
  const yFrom = String(fromQ).slice(0,10).replace(/\//g,"-");
  const yTo   = String(toQ).slice(0,10).replace(/\//g,"-");
  const yFromC = yFrom.replace(/-/g,"");
  const yToC   = yTo.replace(/-/g,"");
  const label8 = label.slice(0,8);                 // e.g., DSN019-S
  const safe   = label.replace(/[^\w.\-]+/g,"_");  // e.g., DSN019-S_MtLemmon

  // validate & show header
  if (!label || !DATE_RE.test(yFrom) || !DATE_RE.test(yTo)){
    headerEl.textContent = "Label: ‚Ä¶ ¬∑ Range: ‚Ä¶ ‚Üí ‚Ä¶";
    statusEl.innerHTML = '<span class="err">‚ùå Missing/invalid label/from/to (need YYYY-MM-DD).</span>';
    disable(dlEl); disable(logEl);
    return;
  }
  headerEl.textContent = `Label: ${label} ¬∑ Range: ${yFrom} ‚Üí ${yTo}`;

  // canonical relative CSV + LOG (exact names the webhook writes)
  const csvRel = `analysis/${label8}/${safe}_${yFromC}_${yToC}.csv`;
  const logRel = `logs/csv-${safe}-${yFromC}${yToC}.log`;

  // absolute URLs
  const CSV_RAW = `${GH_RAW_BASE}/${csvRel}`;
  const CSV_PGS = `${GH_PAGES_BASE}/${csvRel}`;
  const LOG_RAW = `${GH_RAW_BASE}/${logRel}`;
  const LOG_PGS = `${GH_PAGES_BASE}/${logRel}`;

  /* ===== helpers ===== */
  function bust(u){ return u + (u.includes("?")?"&":"?") + "bust=" + Date.now(); }
  function disable(a){ a.classList.add("disabled"); a.setAttribute("aria-disabled","true"); }
  function enable(a){ a.classList.remove("disabled"); a.removeAttribute("aria-disabled"); }
  function debugLite(step, note){
    if (!window.DEBUG_FLAG) return;
    try{
      const payload = {step, note:note||"", label, from:yFrom, to:yTo, t:new Date().toISOString(), lite:true};
      if (navigator.sendBeacon){
        const blob = new Blob([JSON.stringify(payload)], {type:"application/json"});
        navigator.sendBeacon(DEBUG_URL, blob);
      } else {
        const img = new Image(1,1);
        const q   = new URLSearchParams({ s:step, n:(payload.note||"").slice(0,120), l:label, f:yFrom, t:yTo, z:Date.now() });
        img.src   = `${DEBUG_URL}?${q.toString()}`;
      }
    }catch(_e){}
  }
  async function head(url){
    try{ const r = await fetch(bust(url), {method:"HEAD", cache:"no-store"}); return r.ok; }
    catch(_){ return false; }
  }

  async function getStatusFrom(base){
      const u = `${base}/status/status-${encodeURIComponent(label8)}.json`;
      try{
	  const r = await fetch(u + (u.includes('?')?'&':'?') + '_cb=' + Date.now(), {cache:"no-store"});
	  if (!r.ok) return null;
	  return await r.json();
      }catch(_){ return null; }
  }

  async function getStatus(){
      // Try RAW first (usually updates faster), then Pages
      const stRaw = await getStatusFrom("https://raw.githubusercontent.com/soazcomms/soazcomms.github.io/main");
      if (stRaw) return stRaw;
      return await getStatusFrom("https://soazcomms.github.io");
  }
    
  // client-side guard: cleanup must point to a single .csv under analysis/<label8>/
  function isSafeCsv(rel){
    if (!rel) return false;
    if (!rel.endsWith(".csv")) return false;
    if (rel.includes("..")) return false;
    if (!rel.startsWith(`analysis/${label8}/`)) return false;
    return true;
  }

  function armDownload(urls){
    enable(dlEl);
    dlEl.onclick = async (ev)=>{
      ev.preventDefault();
      statusEl.textContent = "Preparing download‚Ä¶";
      const pretty = `${safe}_${yFrom}_${yTo}.csv`;
      for (const u of urls){
        try{
          const r = await fetch(bust(u), {cache:"no-store"});
          if (!r.ok) continue;
          const blob = await r.blob();
          const obj  = URL.createObjectURL(blob);
          const a    = document.createElement("a");
          a.href = obj; a.download = pretty; document.body.appendChild(a); a.click(); a.remove();
          setTimeout(()=>URL.revokeObjectURL(obj), 300);

          // finish UI
          barEl.style.width = "100%";
          statusEl.innerHTML = '<span class="ok">‚úÖ CSV downloaded.</span>';
          hintEl.style.display = "block";
//          hintEl.textContent = "You can close this tab or return to Grafana.";
          try { clearInterval(poll); } catch (_) {}

          if (new URLSearchParams(location.search).get("close") === "1") {
            setTimeout(() => window.close(), 1200);
          }
          return;
        }catch(_){}
      }
      statusEl.innerHTML = '<span class="err">‚ö†Ô∏è Download failed: HTTP 404</span>';
    };
  }

  async function enableLogWhenReady(){
    // raw first
    if (await head(LOG_RAW)) {
      logEl.href = bust(LOG_RAW);
      enable(logEl);
      logEl.onclick = (ev)=>{ ev.preventDefault(); window.open(bust(LOG_RAW), "_blank", "noopener"); };
      return true;
    }
    // then pages mirror
    if (await head(LOG_PGS)) {
      logEl.href = bust(LOG_PGS);
      enable(logEl);
      logEl.onclick = (ev)=>{ ev.preventDefault(); window.open(bust(LOG_PGS), "_blank", "noopener"); };
      return true;
    }
    return false;
  }

  /* ===== boot ===== */
  debugLite("page_load","csv_trigger");

  // make View LOG do something immediately (fallback to status JSON)
  logEl.href = bust(statusJSON());
  enable(logEl);
  logEl.onclick = (ev)=>{ ev.preventDefault(); window.open(bust(statusJSON()), "_blank", "noopener"); };

  // preflight: if CSV already exists, finish immediately (and log it)
  if (await head(CSV_RAW) || await head(CSV_PGS)){
    debugLite("preflight_csv_exists", csvRel);
    // if a real log exists, upgrade the View LOG target
    await enableLogWhenReady();

    barEl.style.width="100%";
    statusEl.innerHTML = '<span class="ok">‚úÖ CSV ready.</span>';
    armDownload([CSV_RAW, CSV_PGS]);
    return;
  }

  // try to upgrade View LOG to real logfile during run
  enableLogWhenReady();

  // kick exactly one CSV job on the server
  try{
    const r = await fetch(WEBHOOK_URL, {
      method:"POST",
      headers:{"Content-Type":"application/json"},
      body: JSON.stringify({label, from:yFrom, to:yTo, csv_only:true}),
      cache:"no-store",
      mode:"cors",
      credentials:"omit"
    });
    if (!r.ok) throw new Error("HTTP "+r.status);
  }catch(e){
    statusEl.innerHTML = `<span class="err">‚ùå CSV job failed to start (${String(e).replace(/[<>&]/g,"")}).</span>`;
    disable(dlEl);
    return;
  }

  // poll: status first, then HEADs
  const poll = setInterval(async ()=>{
    const timedOut = (Date.now()-startedAt) >= (TIMEOUT_MS_INIT + EXTRA_MS);
    tick(timedOut);
    enableLogWhenReady();

    const st = await getStatus();
    if (st && st.phase === "done"){
      const urls = [];
      if (st.csv_raw) urls.push(st.csv_raw + (st.csv_raw.includes("?") ? "&" : "?") + "bust=" + Date.now());
      if (st.csv)     urls.push(st.csv     + (st.csv.includes("?")     ? "&" : "?") + "bust=" + Date.now());
      if (urls.length === 0) urls.push(CSV_RAW, CSV_PGS);
      for (const u of urls){
        if (await head(u)){
          clearInterval(poll);
          barEl.style.width="100%";
          statusEl.innerHTML = '<span class="ok">‚úÖ CSV ready.</span>';
          armDownload(urls);
          return;
        }
      }
    }

    if (await head(CSV_RAW) || await head(CSV_PGS)){
      clearInterval(poll);
      barEl.style.width="100%";
      statusEl.innerHTML = '<span class="ok">‚úÖ CSV ready.</span>';
      await enableLogWhenReady();   // ensure log button active now
      armDownload([CSV_RAW, CSV_PGS]);
      return;
    }

    // hard timeout fallback
    const MAX_MS = 5 * 60_000;
    if ((Date.now()-startedAt) > MAX_MS){
      clearInterval(poll);
      barEl.style.width="100%"; barEl.classList.add("timeout");
      statusEl.innerHTML = '<span class="err">‚ùå File not found where expected.</span>';
      retryEl.style.display="inline-block";
      retryEl.onclick = (ev)=>{ ev.preventDefault(); location.reload(); };
    }
  }, POLL_INTERVAL_MS);

})();
</script>
</html>
