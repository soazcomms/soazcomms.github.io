<!doctype html>
<html lang="en">
<head>
  <meta charset="utf-8" />
  <title>DSN CSV Export</title>
  <meta name="viewport" content="width=device-width,initial-scale=1" />
  <style>
    body{font-family:system-ui,-apple-system,Segoe UI,Roboto,Arial,sans-serif;margin:2rem;line-height:1.45}
    .wrap{max-width:780px}
    h1{margin:0 0 .5rem 0}
    .muted{color:#666}
    .row{margin:1rem 0}
    .btn{display:inline-block;padding:.6rem 1rem;border:1px solid #ddd;border-radius:8px;text-decoration:none;cursor:pointer}
    .btn[disabled]{opacity:.5;pointer-events:none}
    .ok{color:#0a6}
    .err{color:#b00}
    .bar{height:8px;background:#eee;border-radius:6px;overflow:hidden}
    .bar>span{display:block;height:100%;width:0%;transition:width .6s}
    code{background:#f6f8fa;padding:.1rem .3rem;border-radius:4px}
  </style>
</head>
<body>
  <div class="wrap">
    <h1>DSN CSV Export</h1>
    <div class="muted" id="desc">Preparing‚Ä¶</div>

    <div class="row">
      <div class="bar"><span id="bar"></span></div>
    </div>

    <div class="row">
      <a id="download" class="btn" style="display:none;">‚¨á Download CSV</a>
      <a id="viewlog" class="btn" target="_blank" rel="noopener" style="display:none;">ü™µ View log</a>
      <a id="retry" class="btn" href="#" style="display:none;">‚Üª Retry</a>
    </div>

    <div class="row muted" id="status">Waiting for job to start‚Ä¶</div>
  </div>

<script>
// ---------------- CONFIG ----------------
const GH_PAGES_BASE = "https://soazcomms.github.io/";
const WEBHOOK_URL   = "https://sound-kangaroo-unlikely.ngrok-free.app/DSN_csv";
const CLEANUP_URL   = "https://sound-kangaroo-unlikely.ngrok-free.app/DSN_cleanup";
// ---------------------------------------

// helper: wait for first 200 among candidates (tries sequentially with retries)
async function waitForAvailable(candidates, {timeoutMs=20000, intervalMs=1200} = {}) {
  const deadline = Date.now() + timeoutMs;
  let lastErr = null;

  // try each candidate with retries until deadline
  while (Date.now() < deadline) {
    for (const base of candidates) {
      const url = `${base}${base.includes("?") ? "&" : "?"}bust=${Date.now()}`;
      try {
        const r = await fetch(url, { method: "HEAD", cache: "no-store", mode: "cors" });
        if (r.ok) return { ok: true, url };
        lastErr = new Error(`HEAD ${r.status} @ ${url}`);
      } catch (e) {
        lastErr = new Error(`${e.message} @ ${url}`);
      }
    }
    await new Promise(r => setTimeout(r, intervalMs));
  }
  return { ok: false, error: lastErr ? lastErr.message : "timeout" };
}

// download as file
function forceDownload(url, filename) {
  return fetch(url, { cache: "no-store", mode: "cors" })
    .then(r => { if (!r.ok) throw new Error(`HTTP ${r.status} @ ${url}`); return r.blob(); })
    .then(blob => {
      const a = document.createElement("a");
      a.href = URL.createObjectURL(blob);
      a.download = filename;
      document.body.appendChild(a);
      a.click();
      URL.revokeObjectURL(a.href);
      a.remove();
    });
}

(function(){
  const qs      = new URLSearchParams(location.search);
  const label   = (qs.get("label")||"").trim();
  const from    = (qs.get("from") || "").trim();
  const to      = (qs.get("to")   || "").trim();
  const statusEl= document.getElementById("status");
  const barEl   = document.getElementById("bar");
  const dlEl    = document.getElementById("download");
  const logEl   = document.getElementById("viewlog");
  const retryEl = document.getElementById("retry");
  const descEl  = document.getElementById("desc");

  descEl.textContent = `Label: ${label} ¬∑ Range: ${from} ‚Üí ${to}`;

  // normalize YYYY-MM-DD and YYYYMMDD
  const toYMD = s => String(s).slice(0,10).replaceAll("/","-");
  const yFrom = toYMD(from), yTo = toYMD(to);

  // kick the job
  fetch(WEBHOOK_URL, {
    method: "POST",
    headers: { "content-type": "application/json" },
    body: JSON.stringify({ label, from: yFrom, to: yTo })
  }).then(() => {
    statusEl.textContent = "Triggered‚Ä¶ generating CSV";
  }).catch(() => {
    statusEl.textContent = "Triggered (no response)";
  });

  // progress bar
  let pct = 8;
  barEl.style.width = pct + "%";
  const tick = setInterval(() => { pct = Math.min(95, pct + 2); barEl.style.width = pct + "%"; }, 1200);

  // poll status json (do NOT stop just because csv exists)
  const safeLabel = (label || "").replace(/[^\w.\-]+/g, "_");
  const statusRel = `status/status-${safeLabel}.json`;
  const statusURL = GH_PAGES_BASE + statusRel;

  const poll = setInterval(async () => {
    let data;
    try {
      const resp = await fetch(`${statusURL}?bust=${Date.now()}`, { cache: "no-store" });
      if (!resp.ok) return;
      data = await resp.json();
    } catch (_e) { return; }

    // log link
    if (data.log) {
      const logAbs = /^https?:\/\//i.test(data.log)
        ? data.log
        : GH_PAGES_BASE + String(data.log).replace(/^\/+/, "");
      logEl.href = `${logAbs}${logAbs.includes("?") ? "&" : "?"}bust=${Date.now()}`;
      logEl.style.display = "inline-block";
    }

    // wire download (but keep polling)
    const pagesAbs = data.csv
      ? (/^https?:\/\//i.test(data.csv) ? data.csv
         : GH_PAGES_BASE.replace(/\/+$/, "") + "/" + String(data.csv).replace(/^\/+/, ""))
      : "";
    const rawAbs = data.csv_raw || "";
    const candidates = [];
    if (rawAbs)  candidates.push(rawAbs);
    if (pagesAbs) candidates.push(pagesAbs);

    if (candidates.length) {
      const pretty = `${label}_${yFrom}_${yTo}.csv`;
      dlEl.style.display = "inline-block";
      dlEl.onclick = async (ev) => {
        ev.preventDefault();
        dlEl.setAttribute("disabled", "true");
        try {
          // 1) wait for a good URL (handles GH propagation lag)
          statusEl.textContent = "‚è± Checking CSV availability‚Ä¶";
          const found = await waitForAvailable(candidates, { timeoutMs: 30000, intervalMs: 1200 });
          if (!found.ok) throw new Error(`CSV not available: ${found.error}`);

          // 2) download
          statusEl.textContent = "‚¨á Downloading CSV‚Ä¶";
          await forceDownload(found.url, pretty);

          // 3) cleanup (delete CSV in repo so it can't be reused)
          statusEl.textContent = "‚ôªÔ∏è Requesting cleanup‚Ä¶";
          const cResp = await fetch(CLEANUP_URL, {
            method: "POST",
            headers: { "content-type": "application/json" },
            body: JSON.stringify({ label, from: yFrom, to: yTo })
          });
          if (!cResp.ok) throw new Error(`Cleanup HTTP ${cResp.status} @ ${CLEANUP_URL}`);
          const cJson = await cResp.json().catch(()=> ({}));
          if (cJson && cJson.ok) {
            statusEl.textContent = `‚ôªÔ∏è Cleaned: ${cJson.csv || ""}`;
          } else {
            statusEl.textContent = `‚ö†Ô∏è Cleanup responded not-ok: ${JSON.stringify(cJson)}`;
          }
        } catch (e) {
          statusEl.textContent = `‚ö†Ô∏è Download/cleanup error: ${e.message}`;
        } finally {
          dlEl.removeAttribute("disabled");
        }
      };
    }

    // phase handling
    const phase = (data.phase || "").toLowerCase();
    if (phase === "done") {
      clearInterval(poll); clearInterval(tick);
      barEl.style.width = "100%";
      statusEl.innerHTML = '<span class="ok">‚úÖ CSV ready.</span>';
      return;
    }
    if (phase === "error") {
      clearInterval(poll); clearInterval(tick);
      barEl.style.width = "100%";
      const note = data.note ? ` <small>${data.note}</small>` : "";
      statusEl.innerHTML = `<span class="err">‚ùå Failed.</span>${note}`;
      retryEl.style.display = "inline-block";
      return;
    }

    // still running: surface last generator line if provided
    if (data.note && String(data.note).trim().length > 0) {
      statusEl.textContent = `‚öôÔ∏è ${data.note}`;
    } else {
      statusEl.textContent = "‚öôÔ∏è Working‚Ä¶";
    }
  }, 1000);

  retryEl.onclick = (e)=>{ e.preventDefault(); location.reload(); };
})();
</script>
</body>
</html>
