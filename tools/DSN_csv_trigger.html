<!doctype html>
<html lang="en">
<head>
<meta charset="utf-8" />
<title>DSN CSV Export</title>
<meta name="viewport" content="width=device-width,initial-scale=1" />
<style>
  body{font-family:system-ui,-apple-system,Segoe UI,Roboto,Arial,sans-serif;margin:2rem;line-height:1.45}
  .wrap{max-width:780px}
  h1{margin:0 0 .5rem 0}
  .muted{color:#666}
  .row{margin:1rem 0}
  .btn{display:inline-block;padding:.6rem 1rem;border:1px solid #ddd;border-radius:8px;text-decoration:none;cursor:pointer}
  .btn[disabled]{opacity:.5;pointer-events:none}
  .ok{color:#0a6}
  .err{color:#b00}
  .bar{height:8px;background:#eee;border-radius:6px;overflow:hidden}
  .bar>span{display:block;height:100%;width:0%}
  .tiny{font-size:.85rem;color:#777}
</style>
</head>
<body>
<div class="wrap">
  <h1>DSN CSV Export</h1>
  <div class="muted" id="desc">Preparing‚Ä¶</div>

  <div class="row"><div class="bar"><span id="bar"></span></div></div>

  <div class="row">
    <button id="download" class="btn" disabled>‚¨á Download CSV</button>
    <a id="viewlog" class="btn" target="_blank" rel="noopener" style="display:none;">ü™µ View log</a>
    <a id="retry" class="btn" href="#" style="display:none;">‚Üª Retry</a>
  </div>

  <div class="row muted" id="status">Waiting‚Ä¶</div>
  <div class="row tiny" id="debug" style="display:none;"></div>
</div>

<script>
// ======= CONFIG =======
const GH_PAGES_BASE = "https://soazcomms.github.io/";
const WEBHOOK_URL   = "https://sound-kangaroo-unlikely.ngrok-free.app/DSN_csv";
const CLEANUP_URL   = "https://sound-kangaroo-unlikely.ngrok-free.app/DSN_cleanup";

// polling/availability windows
const POLL_MS       = 900;     // status JSON cadence
const AVAIL_MS      = 900;     // CDN availability retry cadence
const MAX_TRIES     = 30;      // bounded tries on click (no infinite hang)
const CLEANUP_DELAY = 4000;    // delete AFTER download trigger (ms)
// =======================

function bust(u){ return `${u}${u.includes("?")?"&":"?"}bust=${Date.now()}`; }

async function tinyOk(url){
  try {
    const r = await fetch(bust(url), { method:"GET", headers:{ "Range":"bytes=0-0" }, cache:"no-store", mode:"cors" });
    return r.ok;
  } catch { return false; }
}

async function forceDownload(url, filename){
  const r = await fetch(bust(url), { cache:"no-store", mode:"cors" });
  if (!r.ok) throw new Error(`HTTP ${r.status}`);
  const blob = await r.blob();
  const a = document.createElement("a");
  const blobUrl = URL.createObjectURL(blob);
  a.href = blobUrl; a.download = filename || "export.csv";
  document.body.appendChild(a); a.click(); a.remove();
  setTimeout(()=> URL.revokeObjectURL(blobUrl), 5000);
}

(function(){
  const qs      = new URLSearchParams(location.search);
  const label   = (qs.get("label")||"").trim();
  const from    = (qs.get("from") || "").trim();
  const to      = (qs.get("to")   || "").trim();

  const descEl  = document.getElementById("desc");
  const statusEl= document.getElementById("status");
  const barEl   = document.getElementById("bar");
  const dlBtn   = document.getElementById("download");
  const logEl   = document.getElementById("viewlog");
  const retryEl = document.getElementById("retry");
  const dbgEl   = document.getElementById("debug");

  descEl.textContent = `Label: ${label} ¬∑ Range: ${from} ‚Üí ${to}`;

  // ALWAYS-ANIMATING PROGRESS via rAF (never dead)
  let pct = 8, running = true;
  let up = true;
  function anim(){
    if (running) {
      // bounce between 10‚Äì95% to show life
      pct += up ? 0.8 : -0.8;
      if (pct > 95) { pct = 95; up = false; }
      if (pct < 10) { pct = 10; up = true; }
      barEl.style.width = pct.toFixed(1) + "%";
    }
    requestAnimationFrame(anim);
  }
  requestAnimationFrame(anim);

  const toYMD = s => String(s).slice(0,10).replaceAll("/","-");
  const yFrom = toYMD(from), yTo = toYMD(to);
  const prettyName = `${label}_${yFrom}_${yTo}.csv`;
  const safeLabel  = (label || "").replace(/[^\w.\-]+/g, "_");
  const statusRel  = `status/status-${safeLabel}.json`;
  const statusURL  = GH_PAGES_BASE + statusRel;

  // Kick job (fire-and-forget)
  fetch(WEBHOOK_URL, {
    method: "POST",
    headers: { "content-type": "application/json" },
    body: JSON.stringify({ label, from: yFrom, to: yTo })
  }).catch(()=>{});

  let pagesAbs = "", rawAbs = "";

  // Download click ‚Äî bounded tries; honest status; no fake timers
  dlBtn.onclick = async () => {
    if (dlBtn.disabled) return;
    dlBtn.disabled = true;

    let use = "";
    for (let i=1; i<=MAX_TRIES; i++){
      statusEl.textContent = `‚¨á Downloading‚Ä¶ try ${i}/${MAX_TRIES}`;
      dbgEl.style.display = "block";
      dbgEl.textContent = (pagesAbs||rawAbs) ? `trying: ${pagesAbs || rawAbs}` : "waiting for URLs‚Ä¶";
      if (pagesAbs && await tinyOk(pagesAbs)) { use = pagesAbs; break; }
      if (rawAbs   && await tinyOk(rawAbs))   { use = rawAbs;   break; }
      await new Promise(r => setTimeout(r, AVAIL_MS));
    }

    if (!use) {
      dlBtn.disabled = false;
      statusEl.innerHTML = `<span class="err">File not live yet (CDN). Click again in a few seconds.</span>`;
      return;
    }

    try {
      await forceDownload(use, prettyName);
      running = false; barEl.style.width = "100%";
      statusEl.innerHTML = `<span class="ok">Download started ‚Äî cleaning up‚Ä¶</span>`;
    } catch (e) {
      dlBtn.disabled = false;
      statusEl.innerHTML = `<span class="err">Download failed: ${e.message}</span>`;
      return;
    }

    // delete AFTER download trigger (your requirement)
    setTimeout(async () => {
      try {
        const cr = await fetch(CLEANUP_URL, {
          method: "POST",
          headers: { "content-type": "application/json" },
          body: JSON.stringify({ label, from: yFrom, to: yTo })
        });
        if (!cr.ok) throw new Error(`Cleanup HTTP ${cr.status}`);
        const js = await cr.json().catch(()=> ({}));
        if (js && js.ok) {
          statusEl.innerHTML = `<span class="ok">Done. CSV removed from server.</span>`;
        } else {
          statusEl.innerHTML = `<span class="err">Cleanup responded not-ok; file may still exist.</span>`;
        }
      } catch (e) {
        statusEl.innerHTML = `<span class="err">Cleanup error: ${e.message}</span>`;
      }
    }, CLEANUP_DELAY);
  };

  // poll status JSON (with cache-buster)
  const poll = setInterval(async () => {
    let data;
    try {
      const resp = await fetch(bust(statusURL), { cache: "no-store" });
      if (!resp.ok) return;
      data = await resp.json();
    } catch { return; }

    // log link
    if (data.log) {
      const logAbs = /^https?:\/\//i.test(data.log)
        ? data.log
        : GH_PAGES_BASE + String(data.log).replace(/^\/+/, "");
      logEl.href = bust(logAbs);
      logEl.style.display = "inline-block";
    }

    // csv urls (both)
    if (data.csv) {
      pagesAbs = /^https?:\/\//i.test(data.csv)
        ? data.csv
        : GH_PAGES_BASE.replace(/\/+$/, "") + "/" + String(data.csv).replace(/^\/+/, "");
    }
    rawAbs = data.csv_raw || (data.csv ? `https://raw.githubusercontent.com/soazcomms.github.io/main/${data.csv}` : "");

    const phase = (data.phase || "").toLowerCase();

    if (phase === "running") {
      statusEl.textContent = data.status || "‚öôÔ∏è Working‚Ä¶";
      return;
    }

    if (phase === "done") {
      clearInterval(poll);
      statusEl.innerHTML = `<span class="ok">‚úÖ CSV ready. Click Download.</span>`;
      dlBtn.disabled = false; // enable immediately
      return;
    }

    if (phase === "error") {
      clearInterval(poll);
      running = false; barEl.style.width = "100%";
      const note = data.note ? ` <small>${data.note}</small>` : "";
      statusEl.innerHTML = `<span class="err">‚ùå Failed.</span>${note}`;
      document.getElementById("retry").style.display = "inline-block";
      document.getElementById("retry").onclick = (e)=>{ e.preventDefault(); location.reload(); };
      return;
    }
  }, POLL_MS);
})();
</script>
</body>
</html>
