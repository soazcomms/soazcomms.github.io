<!doctype html>
<html lang="en">
<head>
<meta charset="utf-8" />
<title>DSN CSV Export (auto-download)</title>
<meta name="viewport" content="width=device-width,initial-scale=1" />
<style>
  body{font-family:system-ui,-apple-system,Segoe UI,Roboto,Arial,sans-serif;margin:2rem;line-height:1.45}
  .muted{color:#666}
  .ok{color:#0a6}
  .err{color:#b00}
</style>
</head>
<body>
<div id="msg" class="muted">Starting…</div>
<script>
// ======= CONFIG (edit if needed) =======
const GH_PAGES_BASE = "https://soazcomms.github.io/";
const WEBHOOK_URL   = "https://sound-kangaroo-unlikely.ngrok-free.app/DSN_csv";
const CLEANUP_URL   = "https://sound-kangaroo-unlikely.ngrok-free.app/DSN_cleanup";
// Download/cleanup timings
const RETRY_MS      = 1200;    // status poll + availability check cadence
const MAX_WAIT_MS   = 120000;  // max wait for CDN after 'done'
const CLEANUP_DELAY = 4000;    // delete AFTER download trigger (ms)
// =======================================

// Parse inputs
const qs    = new URLSearchParams(location.search);
const label = (qs.get("label")||"").trim();
const from  = (qs.get("from") || "").trim();
const to    = (qs.get("to")   || "").trim();
const msgEl = document.getElementById("msg");

function toYMD(s){ return String(s).slice(0,10).replaceAll("/","-"); }
const yFrom = toYMD(from), yTo = toYMD(to);
const safeLabel = (label || "").replace(/[^\w.\-]+/g, "_");

// Kick job (fire-and-forget)
fetch(WEBHOOK_URL, {
  method: "POST",
  headers: { "content-type": "application/json" },
  body: JSON.stringify({ label, from: yFrom, to: yTo })
}).catch(()=>{});

// Status JSON
const statusRel = `status/status-${safeLabel}.json`;
const statusURL = GH_PAGES_BASE + statusRel;

// Helper: tiny HEAD-ish fetch (Range 0-0) to test availability without caching
async function tinyOk(url){
  const u = `${url}${url.includes("?") ? "&" : "?"}bust=${Date.now()}`;
  try{
    const r = await fetch(u, { method:"GET", headers:{ "Range":"bytes=0-0" }, cache:"no-store", mode:"cors" });
    return r.ok;
  }catch{ return false; }
}

// Helper: fetch CSV as Blob and force browser download (no preview)
async function forceDownload(url, filename){
  const u = `${url}${url.includes("?") ? "&" : "?"}bust=${Date.now()}`;
  const r = await fetch(u, { cache:"no-store", mode:"cors" });
  if(!r.ok) throw new Error(`HTTP ${r.status}`);
  const blob = await r.blob();
  const a = document.createElement("a");
  const blobUrl = URL.createObjectURL(blob);
  a.href = blobUrl;
  a.download = filename || "export.csv";
  document.body.appendChild(a);
  a.click();
  a.remove();
  setTimeout(()=> URL.revokeObjectURL(blobUrl), 5000);
}

// Poll for status -> when done, try to download via Pages then Raw
(async function main(){
  if(!label || !from || !to){
    msgEl.className = "err";
    msgEl.textContent = "Missing required query params: label, from, to";
    return;
  }
  msgEl.textContent = `Running for ${label} ${yFrom} → ${yTo}…`;

  let phase = "";
  let csvRel = "", rawAbs = "", pagesAbs = "";
  let started = Date.now();

  // Poll status until phase: done or error
  while(true){
    try{
      const r = await fetch(`${statusURL}?bust=${Date.now()}`, { cache: "no-store" });
      if(r.ok){
        const data = await r.json();
        phase = (data.phase || "").toLowerCase();
        csvRel = data.csv || "";
        if(csvRel){
          pagesAbs = /^https?:\/\//i.test(csvRel) ? csvRel
                    : GH_PAGES_BASE.replace(/\/+$/, "") + "/" + String(csvRel).replace(/^\/+/, "");
          rawAbs   = data.csv_raw || `https://raw.githubusercontent.com/soazcomms.github.io/main/${csvRel}`;
        }
        if(phase === "done" || phase === "error") break;
        msgEl.textContent = data.status || `Working… (+${Math.floor((Date.now()-started)/1000)}s)`;
      }
    }catch{ /* ignore */ }
    await new Promise(r => setTimeout(r, RETRY_MS));
    if(Date.now() - started > 30*60*1000){ // safety net 30 min
      msgEl.className = "err";
      msgEl.textContent = "Timed out waiting for completion.";
      return;
    }
  }

  if(phase === "error"){
    msgEl.className = "err";
    msgEl.textContent = "Job failed. Check the log in your repo.";
    return;
  }

  // 'done' -> wait for CSV to be actually reachable, then download
  msgEl.className = "muted";
  msgEl.textContent = "Preparing your download…";

  const pretty = `${label}_${yFrom}_${yTo}.csv`;
  const deadline = Date.now() + MAX_WAIT_MS;
  let urlToUse = "";

  while(Date.now() < deadline){
    if(pagesAbs && await tinyOk(pagesAbs)){ urlToUse = pagesAbs; break; }
    if(rawAbs   && await tinyOk(rawAbs)){   urlToUse = rawAbs;   break; }
    await new Promise(r => setTimeout(r, RETRY_MS));
  }

  if(!urlToUse){
    msgEl.className = "err";
    msgEl.textContent = "File not available yet (CDN delay). Try refreshing this page in a few seconds.";
    return;
  }

  try{
    await forceDownload(urlToUse, pretty);
    msgEl.className = "ok";
    msgEl.textContent = "Download started. Cleaning up…";
  }catch(e){
    msgEl.className = "err";
    msgEl.textContent = `Download failed: ${e.message}`;
    return;
  }

  // Cleanup AFTER a short delay (never before)
  setTimeout(async () => {
    try{
      const cr = await fetch(CLEANUP_URL, {
        method: "POST",
        headers: { "content-type": "application/json" },
        body: JSON.stringify({ label, from: yFrom, to: yTo })
      });
      if(!cr.ok) throw new Error(`Cleanup HTTP ${cr.status}`);
      const js = await cr.json().catch(()=>({}));
      if(js && js.ok){
        msgEl.textContent = "Done. CSV removed from server.";
      }else{
        msgEl.textContent = "Download complete. Cleanup response not-ok (file may still be present).";
      }
    }catch(e){
      msgEl.textContent = `Download complete. Cleanup error: ${e.message}`;
    }
  }, CLEANUP_DELAY);
})();
</script>
</body>
</html>
