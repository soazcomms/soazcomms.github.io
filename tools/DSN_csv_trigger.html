<!doctype html>
<html lang="en">
<meta charset="utf-8" />
<title>DSN CSV Export</title>
<meta name="viewport" content="width=device-width,initial-scale=1" />
<style>
  body{font-family:system-ui,-apple-system,Segoe UI,Roboto,Arial,sans-serif;margin:20px;line-height:1.45}
  .wrap{max-width:780px}
  h1{margin:0 0 .5rem 0}
  .muted{color:#666}
  .row{margin:1rem 0}
  .btn{display:inline-block;padding:.6rem 1rem;border:1px solid #ddd;border-radius:8px;text-decoration:none;cursor:pointer}
  .btn.disabled{opacity:.5;pointer-events:none}
  .ok{color:#0a6}
  .err{color:#b00}

  /* ==== DSN_trigger-style progress UI (kept as-is) ==== */
  .progress-wrap { width:min(720px,90vw); margin:.75rem 0 .25rem; text-align:center; }
  .progress { width:50%; margin:0 auto; height:12px; background:#edf2f7; border-radius:999px; overflow:hidden; box-shadow:inset 0 0 0 1px #e2e8f0; }
  .legend { width:50%; margin:.35rem auto 0; display:flex; justify-content:space-between; font-size:.85rem; color:#555; }
  .bar { height:100%; width:0%; background:linear-gradient(90deg,#69c,#38bdf8 40%,#22c55e 75%,#16a34a 100%); transition:width .4s ease; }
  .bar.timeout { background:linear-gradient(90deg,#f59e0b,#ef4444); }

  .hint{font-size:.9rem;color:#666}
</style>

<div class="wrap" id="wrap">
  <h1>DSN CSV Export</h1>
  <div class="muted" id="desc">Preparing‚Ä¶</div>

  <!-- Progress bar + timer -->
  <div class="progress-wrap" aria-label="Progress toward timeout window">
    <div class="progress"><div id="bar" class="bar" role="progressbar" aria-valuemin="0" aria-valuemax="100" aria-valuenow="0"></div></div>
    <div class="legend"><span id="leg-left" class="muted">0:00</span><span id="leg-right" class="muted">Timeout in 7:00</span></div>
  </div>

  <div class="row">
    <a id="download" class="btn disabled" href="#">‚¨á Download CSV</a>
    <a id="viewlog" class="btn disabled" target="_blank" rel="noopener" href="#">ü™µ View log</a>
    <a id="retry"   class="btn" href="#" style="display:none;">‚Üª Retry</a>
  </div>

  <div class="row muted" id="status">‚öôÔ∏è Working‚Ä¶</div>
  <div class="row hint"   id="hint" style="display:none;"></div>
</div>

<!-- pulls DEBUG_TURD=true/false if your env.js defines it -->
<script src="https://sound-kangaroo-unlikely.ngrok-free.app/env.js"></script>
<script>
  // If env.js didn‚Äôt set it, default true so we see pings while wiring
  if (typeof window.DEBUG_TURD === "undefined") window.DEBUG_TURD = true;
</script>

<script>
(function(){
  // ===== constants (kept) =====
  var GH_PAGES_BASE = "https://soazcomms.github.io";
  var GH_RAW_BASE   = "https://raw.githubusercontent.com/soazcomms/soazcomms.github.io/main";
  const DEFAULT_WEBHOOK = "https://sound-kangaroo-unlikely.ngrok-free.app";
  const qs = new URLSearchParams(location.search);
  const WEBHOOK_ORIG = (qs.get("webhook") || DEFAULT_WEBHOOK).replace(/\/+$/,"");

  // endpoints (kept names)
  const WEBHOOK_URL = WEBHOOK_ORIG + "/webhook";
  const CLEANUP_URL = WEBHOOK_ORIG + "/DSN_cleanup";
  const TURD_URL    = WEBHOOK_ORIG + "/DSN_turd";

  // ===== DOM (kept) =====
  var statusEl= document.getElementById("status");
  var barEl   = document.getElementById("bar");
  var legL    = document.getElementById("leg-left");
  var legR    = document.getElementById("leg-right");
  var dlEl    = document.getElementById("download");
  var logEl   = document.getElementById("viewlog");
  var retryEl = document.getElementById("retry");
  var descEl  = document.getElementById("desc");
  var hintEl  = document.getElementById("hint");

  // ===== timers (kept) =====
  var POLL_INTERVAL_MS = 900;
  var TIMEOUT_MS_INIT  = 7 * 60_000;
  var EXTRA_MS         = 0;
  var jobStart         = Date.now();

  function mmss(ms){ var s=Math.max(0,Math.floor(ms/1000)); return Math.floor(s/60)+":"+String(s%60).padStart(2,"0"); }
  function updateProgress(timedOut){
    var elapsed = Date.now()-jobStart, total = TIMEOUT_MS_INIT + EXTRA_MS;
    var pct = Math.max(3, Math.min(100, Math.floor(elapsed/total*100)));
    barEl.style.width = pct + "%";
    if (timedOut) barEl.classList.add("timeout"); else barEl.classList.remove("timeout");
    legL.textContent = mmss(elapsed);
    legR.textContent = timedOut ? "Waiting‚Ä¶" : ("Timeout in " + mmss(Math.max(0, total - elapsed)));
  }
  function softExtend(ms, why){
    EXTRA_MS += ms;
    turdLite("auto_extend", why ? (why+" +" + Math.round(ms/60000) + "m") : ("+" + Math.round(ms/60000) + "m"));
  }

  // ===== inputs (kept) =====
  var label = (qs.get("label")||"").trim();
  var fromQ = (qs.get("from")  ||"").trim();
  var toQ   = (qs.get("to")    ||"").trim();
  function toYMD(s){ return String(s).slice(0,10).replace(/\//g,"-"); }
  var yFrom = toYMD(fromQ), yTo = toYMD(toQ);
  var yFromC = yFrom.replace(/-/g,""); var yToC = yTo.replace(/-/g,"");
  var safeLabel = (label||"").replace(/[^\w.\-]+/g, "_");
  descEl.textContent = "Label: "+label+" ¬∑ Range: "+yFrom+" ‚Üí "+yTo;

  // paths (kept)
  var csvRel = "DSNdata/"+safeLabel+"_"+yFromC+"_"+yToC+".csv";
  var logRel = "logs/csv-"+safeLabel+"-"+yFromC+yToC+".log";
  var csvRAW = GH_RAW_BASE+"/"+csvRel;
  var csvPGS = GH_PAGES_BASE+"/"+csvRel;
  var logRAW = GH_RAW_BASE+"/"+logRel;
  var logPGS = GH_PAGES_BASE+"/"+logRel;

  // ===== helpers (kept) =====
  function bust(u){ return u + (u.indexOf("?")>-1 ? "&" : "?") + "bust=" + Date.now(); }
  function setDisabled(a, dis){ if(dis){ a.classList.add("disabled"); a.setAttribute("aria-disabled","true"); } else { a.classList.remove("disabled"); a.removeAttribute("aria-disabled"); } }
  function xhrHEAD(url, ok, fail){
    try{
      var x = new XMLHttpRequest();
      x.open("HEAD", bust(url), true);
      x.onreadystatechange = function(){
        if (x.readyState === 4){
          if (x.status>=200 && x.status<400) ok(x.status); else fail && fail(x.status);
        }
      };
      x.send(null);
    }catch(e){ fail && fail(0); }
  }
  function xhrGETBlob(url, ok, fail){
    try{
      var x = new XMLHttpRequest();
      x.open("GET", bust(url), true);
      x.responseType = "blob";
      x.onreadystatechange = function(){
        if (x.readyState === 4){
          if (x.status>=200 && x.status<400) ok(x.response);
          else fail && fail(x.status);
        }
      };
      x.send(null);
    }catch(e){ fail && fail(0); }
  }

  // ===== logging: existing JSON POST logger (kept) =====
  const RUN_ID = "run-" + Date.now() + "-" + Math.random().toString(36).slice(2,8);
  function postJSON(url, obj, ok, fail){
    try{
      var x = new XMLHttpRequest();
      x.open("POST", url, true);
      x.setRequestHeader("content-type","application/json");
      x.onreadystatechange = function(){
        if (x.readyState === 4){
          if (x.status>=200 && x.status<400) ok && ok(x.responseText);
          else fail && fail(x.status, x.responseText);
        }
      };
      x.onerror = function(){ fail && fail(0, "network error"); };
      var payload = Object.assign({run_id: RUN_ID, t: new Date().toISOString()}, obj||{});
      x.send(JSON.stringify(payload));
    }catch(e){ fail && fail(0, String(e)); }
  }
  function turd(step, note){
    if (!window.DEBUG_TURD) return;
    postJSON(TURD_URL, {step:step, note:note||"", label:label, from:yFrom, to:yTo, run_id:RUN_ID});
  }

  /* ===== NEW: ultra-lightweight logger (‚Äúpixel‚Äù style) =====
     Uses sendBeacon when available; falls back to GETing a 1√ó1 image.
     Does not block UI; safe to sprinkle anywhere.
  */
  function turdLite(step, note){
    if (!window.DEBUG_TURD) return;
    try{
      var payload = {step:step, note:note||"", label:label, from:yFrom, to:yTo, run_id:RUN_ID, t:new Date().toISOString(), lite:true};
      if (navigator.sendBeacon){
        var blob = new Blob([JSON.stringify(payload)], {type: "application/json"});
        navigator.sendBeacon(TURD_URL, blob);
      } else {
        // fall back to a GET pixel; params compact to avoid long URLs
        var img = new Image(1,1);
        var q = new URLSearchParams({
          s: step, n: (note||"").slice(0,120),
          l: label, f: yFrom, t: yTo, r: RUN_ID, z: Date.now()
        });
        img.src = TURD_URL + "?" + q.toString();
      }
    }catch(_e){}
  }

  // point log button at status JSON immediately
  function statusJSON(){ return GH_PAGES_BASE + "/status/status-" + encodeURIComponent(safeLabel) + ".json"; }
  function tryEnableLog(){
    xhrHEAD(logRAW, function(){ logEl.href = bust(logRAW); setDisabled(logEl,false); turdLite("log_head_ok","raw"); },
                  function(){ xhrHEAD(logPGS, function(){ logEl.href = bust(logPGS); setDisabled(logEl,false); turdLite("log_head_ok","pages"); }); });
  }

  function confirmCleanup(csvRelPath){
    var raw = GH_RAW_BASE + "/" + csvRelPath;
    var pgs = GH_PAGES_BASE + "/" + csvRelPath;
    var attempts = 0, maxTry = 120;
    var iv = setInterval(function(){
      attempts++; turdLite("cleanup_check","try "+attempts);
      xhrHEAD(raw, function(){ /* still there */ }, function(){
        clearInterval(iv);
        turdLite("cleanup_confirmed_raw","gone");
        hintEl.style.display="block";
        hintEl.textContent = "üßπ Cleanup confirmed.";
        setTimeout(function(){
          xhrHEAD(pgs, function(){ turdLite("cleanup_pages_cached"); },
                       function(){ turdLite("cleanup_pages_gone"); });
        }, 0);
      });
      if (attempts >= maxTry){
        clearInterval(iv);
        turdLite("cleanup_timeout","raw/pages cache linger");
        hintEl.style.display="block";
        hintEl.textContent = "üßπ Cleanup requested. Pages may cache briefly.";
      }
    }, 1500);
  }

  function armDownload(urls){
    setDisabled(dlEl,false);
    dlEl.onclick = function(e){
      e.preventDefault();
      statusEl.textContent = "Preparing download‚Ä¶";
      turdLite("download_click","start");
      var pretty = safeLabel+"_"+yFrom+"_"+yTo+".csv";
      (function tryNext(i){
        if (i>=urls.length){ statusEl.innerHTML = "‚ö†Ô∏è Download failed: HTTP 404"; turdLite("download_fail"); return; }
        var u = urls[i];
        turdLite("download_try", u);
        xhrGETBlob(u, function(blob){
          var obj = URL.createObjectURL(blob);
          var a = document.createElement("a"); a.href = obj; a.download = pretty;
          document.body.appendChild(a); a.click(); a.remove();
          setTimeout(function(){ URL.revokeObjectURL(obj); }, 1500);

          // request cleanup after user download
          turdLite("cleanup_request", csvRel);
          postJSON(CLEANUP_URL, {csv: csvRel},
            function(){ turdLite("cleanup_sent_ok"); },
            function(){ turdLite("cleanup_sent_fail"); }
          );
          confirmCleanup(csvRel);

          // finish UI
          barEl.style.width="100%";
          statusEl.innerHTML = '<span class="ok">‚úÖ CSV downloaded. Cleaning up‚Ä¶</span>';
          hintEl.style.display="block"; hintEl.textContent = "If your browser blocks the first attempt, click Download again.";
          turdLite("download_done");
        }, function(){ tryNext(i+1); });
      })(0);
    };
  }

  // === boot ===
  turdLite("page_load","HTML");
  turdLite("params", JSON.stringify({label:label,from:yFrom,to:yTo}));
  if (!label || !yFrom || !yTo){
    statusEl.innerHTML = '<span class="err">‚ùå Missing label/from/to.</span>';
    setDisabled(dlEl,true); setDisabled(logEl,true); turdLite("param_error");
    return;
  }

  // enable log early (status JSON)
  logEl.href = bust(statusJSON());
  setDisabled(logEl,false);

  // kick the job
  postJSON(WEBHOOK_URL, {label:label, from:yFrom, to:yTo},
    function(){ turdLite("post_job_ok"); },
    function(code, body){ turdLite("post_job_fail", "code="+code); }
  );

  // poll for CSV + animate progress bar
  var MAX_MS = 180000;
  var loop = setInterval(function(){
    var timedOut = (Date.now()-jobStart) >= (TIMEOUT_MS_INIT + EXTRA_MS);
    updateProgress(timedOut);

    tryEnableLog();

    xhrHEAD(GH_RAW_BASE+"/"+csvRel, function(code){
      clearInterval(loop);
      barEl.style.width="100%";
      statusEl.innerHTML = '<span class="ok">‚úÖ CSV ready.</span>';
      armDownload([GH_RAW_BASE+"/"+csvRel, GH_PAGES_BASE+"/"+csvRel]);
      turdLite("csv_head_ok","raw="+code);
    }, function(){
      xhrHEAD(GH_PAGES_BASE+"/"+csvRel, function(code2){
        clearInterval(loop);
        barEl.style.width="100%";
        statusEl.innerHTML = '<span class="ok">‚úÖ CSV ready.</span>';
        armDownload([GH_RAW_BASE+"/"+csvRel, GH_PAGES_BASE+"/"+csvRel]);
        turdLite("csv_head_ok","pages="+code2);
      }, function(){
        if ((Date.now()-jobStart) > MAX_MS){
          clearInterval(loop);
          barEl.style.width="100%"; barEl.classList.add("timeout");
          statusEl.innerHTML = '<span class="err">‚ùå File not found where expected.</span>';
          retryEl.style.display="inline-block";
          retryEl.onclick = function(ev){ ev.preventDefault(); turdLite("retry_click"); location.reload(); };
          turdLite("timeout_no_csv", "rel="+csvRel);
        }
      });
    });
  }, POLL_INTERVAL_MS);
})();
</script>
</html>
