<!doctype html>
<html lang="en">
<head>
<meta charset="utf-8" />
<title>DSN CSV Export</title>
<meta name="viewport" content="width=device-width,initial-scale=1" />
<style>
  body{font-family:system-ui,-apple-system,Segoe UI,Roboto,Arial,sans-serif;margin:2rem;line-height:1.45}
  .wrap{max-width:780px}
  h1{margin:0 0 .5rem 0}
  .muted{color:#666}
  .row{margin:1rem 0}
  .btn{display:inline-block;padding:.6rem 1rem;border:1px solid #ddd;border-radius:8px;text-decoration:none;cursor:pointer}
  .btn[disabled]{opacity:.5;pointer-events:none}
  .ok{color:#0a6}
  .err{color:#b00}
  .bar{height:8px;background:#eee;border-radius:6px;overflow:hidden}
  .bar>span{display:block;height:100%;width:0%;transition:width .5s}
  .hint{font-size:.9rem;color:#666}
  iframe.dl{display:none;width:0;height:0;border:0}
</style>
</head>
<body>
<div class="wrap">
  <h1>DSN CSV Export</h1>
  <div class="muted" id="desc">Preparing‚Ä¶</div>

  <div class="row"><div class="bar"><span id="bar"></span></div></div>

  <div class="row">
    <a id="download" class="btn" style="display:none;">‚¨á Download CSV</a>
    <a id="viewlog" class="btn" target="_blank" rel="noopener" style="display:none;">ü™µ View log</a>
    <a id="retry" class="btn" href="#" style="display:none;">‚Üª Retry</a>
  </div>

  <div class="row muted" id="status">Waiting for job to start‚Ä¶</div>
  <div class="row hint" id="hint" style="display:none;">After you click <b>Download</b>, the file will be removed a few seconds later.</div>

  <!-- hidden iframe used to trigger same-origin navigation download (Safari/Chromium safe) -->
  <iframe id="dlFrame" class="dl" sandbox></iframe>
</div>

<script>
// ------- CONFIG -------
const GH_PAGES_BASE = "https://soazcomms.github.io/";
const WEBHOOK_URL   = "https://sound-kangaroo-unlikely.ngrok-free.app/DSN_csv";
const CLEANUP_URL   = "https://sound-kangaroo-unlikely.ngrok-free.app/DSN_cleanup";
const CLEANUP_DELAY_MS = 5000;   // delete a few seconds AFTER click
const VERIFY_MS        = 4000;   // brief verify window; if not live, skip cleanup
// ----------------------

// lightweight checker (prevents deleting a file that isn‚Äôt live yet)
async function tinyOk(url) {
  const u = `${url}${url.includes("?") ? "&" : "?"}bust=${Date.now()}`;
  try {
    const r = await fetch(u, { method:"GET", headers:{ "Range":"bytes=0-0" }, cache:"no-store", mode:"cors" });
    return r.ok;
  } catch { return false; }
}

(function(){
  const qs      = new URLSearchParams(location.search);
  const label   = (qs.get("label")||"").trim();
  const from    = (qs.get("from") || "").trim();
  const to      = (qs.get("to")   || "").trim();
  const statusEl= document.getElementById("status");
  const barEl   = document.getElementById("bar");
  const dlEl    = document.getElementById("download");
  const logEl   = document.getElementById("viewlog");
  const retryEl = document.getElementById("retry");
  const descEl  = document.getElementById("desc");
  const hintEl  = document.getElementById("hint");
  const dlFrame = document.getElementById("dlFrame");

  descEl.textContent = `Label: ${label} ¬∑ Range: ${from} ‚Üí ${to}`;

  // progress bar that always moves while running/publishing
  let pct = 8;
  barEl.style.width = pct + "%";
  const tick = setInterval(() => {
    try { pct = Math.min(98, pct + 2); barEl.style.width = pct + "%"; } catch {}
  }, 900);

  const toYMD = s => String(s).slice(0,10).replaceAll("/","-");
  const yFrom = toYMD(from), yTo = toYMD(to);

  // kick job
  fetch(WEBHOOK_URL, {
    method: "POST",
    headers: { "content-type": "application/json" },
    body: JSON.stringify({ label, from: yFrom, to: yTo })
  }).then(() => {
    statusEl.textContent = "Triggered‚Ä¶ generating CSV";
  }).catch(() => {
    statusEl.textContent = "Triggered (no response)";
  });

  const safeLabel = (label || "").replace(/[^\w.\-]+/g, "_");
  const statusRel = `status/status-${safeLabel}.json`;
  const statusURL = GH_PAGES_BASE + statusRel;

  const poll = setInterval(async () => {
    let data;
    try {
      const resp = await fetch(`${statusURL}?bust=${Date.now()}`, { cache: "no-store" });
      if (!resp.ok) return;
      data = await resp.json();
    } catch { return; }

    // show elapsed seconds even if note missing
    if ((data.phase || "").toLowerCase() === "running" && typeof data.timestamp === "number") {
      const age = Math.max(0, Math.floor(Date.now()/1000) - data.timestamp);
      statusEl.textContent = data.note && data.note.trim().length
        ? `‚öôÔ∏è ${data.note} (+${age}s)`
        : `‚öôÔ∏è Working‚Ä¶ (+${age}s)`;
    }

    // log link
    if (data.log) {
      const logAbs = /^https?:\/\//i.test(data.log)
        ? data.log
        : GH_PAGES_BASE + String(data.log).replace(/^\/+/, "");
      logEl.href = `${logAbs}${logAbs.includes("?") ? "&" : "?"}bust=${Date.now()}`;
      logEl.style.display = "inline-block";
    }

    // CSV URL on Pages (same-origin with this page)
    const pagesAbs = data.csv
      ? (/^https?:\/\//i.test(data.csv) ? data.csv
         : GH_PAGES_BASE.replace(/\/+$/, "") + "/" + String(data.csv).replace(/^\/+/, ""))
      : "";

    const phase = (data.phase || "").toLowerCase();
    if (phase === "done") {
      clearInterval(poll); clearInterval(tick);
      barEl.style.width = "100%";
      statusEl.innerHTML = '<span class="ok">‚úÖ CSV ready.</span>';
      hintEl.style.display = "block";

      if (pagesAbs) {
        const pretty = `${label}_${yFrom}_${yTo}.csv`;
        const bust   = `${pagesAbs}${pagesAbs.includes("?") ? "&" : "?"}bust=${Date.now()}`;
        dlEl.href = bust;
        dlEl.download = pretty;
        dlEl.style.display = "inline-block";

        dlEl.onclick = async () => {
          // trigger a same-origin navigation download (Safari-safe)
          try { dlFrame.src = `${pagesAbs}${pagesAbs.includes("?") ? "&" : "?"}bust=${Date.now()}`; } catch {}
          statusEl.textContent = "‚¨á Download started‚Ä¶ will remove the file after a short delay.";

          // verify briefly that the file is live (avoid premature deletion)
          const t0 = Date.now();
          let ok = false;
          while (Date.now() - t0 < VERIFY_MS) {
            if (await tinyOk(pagesAbs)) { ok = true; break; }
            await new Promise(r => setTimeout(r, 350));
          }

          setTimeout(async () => {
            if (!ok) {
              statusEl.textContent = "‚ö†Ô∏è Skipped cleanup (file not verified yet). You can re-open this page later to delete.";
              return;
            }
            try {
              const cResp = await fetch(CLEANUP_URL, {
                method: "POST",
                headers: { "content-type": "application/json" },
                body: JSON.stringify({ label, from: yFrom, to: yTo })
              });
              if (!cResp.ok) throw new Error(`Cleanup HTTP ${cResp.status}`);
              const cJson = await cResp.json().catch(()=> ({}));
              if (cJson && cJson.ok) {
                statusEl.textContent = "‚ôªÔ∏è CSV deleted on server after your download.";
              } else {
                statusEl.textContent = `‚ö†Ô∏è Cleanup responded not-ok: ${JSON.stringify(cJson)}`;
              }
            } catch (e) {
              statusEl.textContent = `‚ö†Ô∏è Cleanup error: ${e.message}`;
            }
          }, CLEANUP_DELAY_MS);
        };
      }
      return;
    }

    if (phase === "error") {
      clearInterval(poll); clearInterval(tick);
      barEl.style.width = "100%";
      const note = data.note ? ` <small>${data.note}</small>` : "";
      statusEl.innerHTML = `<span class="err">‚ùå Failed.</span>${note}`;
      document.getElementById("retry").style.display = "inline-block";
      return;
    }
  }, 900);

  document.getElementById("retry").onclick = (e)=>{ e.preventDefault(); location.reload(); };
})();
</script>
</body>
</html>
