<!doctype html>
<html lang="en">
<meta charset="utf-8" />
<title>DSN CSV Export</title>
<meta name="viewport" content="width=device-width,initial-scale=1" />
<style>
  body{font-family:system-ui,-apple-system,Segoe UI,Roboto,Arial,sans-serif;margin:20px;line-height:1.45}
  .wrap{max-width:780px}
  h1{margin:0 0 .5rem 0}
  .muted{color:#666}
  .row{margin:1rem 0}
  .btn{display:inline-block;padding:.6rem 1rem;border:1px solid #ddd;border-radius:8px;text-decoration:none;cursor:pointer}
  .btn.disabled{opacity:.5;pointer-events:none}
  .ok{color:#0a6}
  .err{color:#b00}

  /* keep your bar styling as you had it (no size/color changes) */
  .bar{height:14px;background:#222;border-radius:7px;overflow:hidden;outline:2px solid #900}
  .bar>span{display:block;height:100%;width:0%;
            background:#ff1744;
            box-shadow:0 0 6px #ff1744,0 0 12px #ff1744;
            transition:width .45s ease}
  .done .bar>span{background:#18c37e;box-shadow:0 0 6px #18c37e,0 0 12px #18c37e}
  .hint{font-size:.9rem;color:#666}
</style>

<div class="wrap" id="wrap">
  <h1>DSN CSV Export</h1>
  <div class="muted" id="desc">Preparing‚Ä¶</div>

  <div class="row"><div class="bar"><span id="bar"></span></div></div>

  <div class="row">
    <!-- visible from the start; disabled until ready -->
    <a id="download" class="btn disabled" href="#">‚¨á Download CSV</a>
    <a id="viewlog" class="btn" target="_blank" rel="noopener" style="display:none;">ü™µ View log</a>
    <a id="retry" class="btn" href="#" style="display:none;">‚Üª Retry</a>
  </div>

  <div class="row muted" id="status">‚öôÔ∏è Working‚Ä¶</div>
  <div class="row hint" id="hint" style="display:none;"></div>
</div>

<script>
(() => {
  // --- constants
  const GH_PAGES_BASE = "https://soazcomms.github.io";
  const GH_RAW_BASE   = "https://raw.githubusercontent.com/soazcomms/soazcomms.github.io/main";
  const WEBHOOK_URL   = "https://sound-kangaroo-unlikely.ngrok-free.app/DSN_csv";
  const CLEANUP_URL   = "https://sound-kangaroo-unlikely.ngrok-free.app/DSN_cleanup";

  // --- elements & params
  const qs      = new URLSearchParams(location.search);
  const label   = (qs.get("label")||"").trim();
  const fromQ   = (qs.get("from") || "").trim();
  const toQ     = (qs.get("to")   || "").trim();
  const toYMD   = s => String(s).slice(0,10).replaceAll("/","-");
  const yFrom   = toYMD(fromQ), yTo = toYMD(toQ);
  const yFromC  = yFrom.replaceAll("-","");
  const yToC    = yTo.replaceAll("-","");

  const wrapEl  = document.getElementById("wrap");
  const statusEl= document.getElementById("status");
  const barEl   = document.getElementById("bar");
  const dlEl    = document.getElementById("download");
  const logEl   = document.getElementById("viewlog");
  const retryEl = document.getElementById("retry");
  const descEl  = document.getElementById("desc");
  const hintEl  = document.getElementById("hint");

  if (descEl) descEl.textContent = `Label: ${label} ¬∑ Range: ${yFrom} ‚Üí ${yTo}`;

  // show Download from the start (disabled)
  dlEl.classList.add("disabled");
  dlEl.href = "#";

  // --- helpers
  const bust = u => u + (u.includes("?") ? "&" : "?") + "bust=" + Date.now();

  // GET probe (HEAD is flaky vs GH/CDN/CORS)
  async function getOk(u){
    if (!u) return false;
    try { const r = await fetch(bust(u), { method:"GET", cache:"no-store", redirect:"follow" }); return r.ok; }
    catch { return false; }
  }

  // derive safe label and status url
  const safeLabel = (label||"").replace(/[^\w.\-]+/g, "_");
  const statusRel = `status/status-${safeLabel}.json`;
  const rawStatus = `${GH_RAW_BASE}/${statusRel}`;
  const pagesStatus = `${GH_PAGES_BASE}/${statusRel}`;

  async function getStatus() {
    try { const r = await fetch(bust(rawStatus), {cache:"no-store"});  if (r.ok) return await r.json(); } catch {}
    try { const r = await fetch(bust(pagesStatus), {cache:"no-store"});if (r.ok) return await r.json(); } catch {}
    return null;
  }

  // compute expected CSV path purely from QS (works even if status JSON is stale or csv_raw is malformed)
  const expectedRel  = `DSNdata/${safeLabel}_${yFromC}_${yToC}.csv`;
  const rawGuessURL  = `${GH_RAW_BASE}/${expectedRel}`;
  const pagesGuessURL= `${GH_PAGES_BASE}/${expectedRel}`;

  const armDownload = (finalUrl) => {
    dlEl.href = bust(finalUrl);
    dlEl.download = `${label}_${yFrom}_${yTo}.csv`;
    dlEl.classList.remove("disabled");
    // fire-and-forget cleanup AFTER click
    dlEl.onclick = () => {
      setTimeout(()=>{ fetch(CLEANUP_URL, {
        method:"POST", headers:{ "content-type":"application/json" },
        body: JSON.stringify({ label, from: yFrom, to: yTo })
      }).catch(()=>{}); }, 7000);
    };
  };

  const finish = (finalUrl) => {
    clearInterval(tPoll); clearInterval(tTick);
    if (barEl) barEl.style.width = "100%";
    wrapEl.classList.add("done");
    statusEl.innerHTML = '<span class="ok">‚úÖ CSV ready.</span>';
    armDownload(finalUrl);
    if (hintEl){ hintEl.style.display="block"; hintEl.textContent="If your browser blocks the first attempt, click again."; }
  };

  const fail = (msg="") => {
    clearInterval(tPoll); clearInterval(tTick);
    if (barEl) barEl.style.width = "100%";
    statusEl.innerHTML = `<span class="err">‚ùå Failed.</span> ${msg}`;
    retryEl.style.display = "inline-block";
    retryEl.onclick = (e)=>{ e.preventDefault(); location.reload(); };
  };

  // kick the webhook (best-effort)
  fetch(WEBHOOK_URL, {
    method:"POST", headers:{ "content-type":"application/json" },
    body: JSON.stringify({ label, from: yFrom, to: yTo })
  }).then(()=>{ statusEl.textContent = "Triggered‚Ä¶ generating CSV"; })
    .catch(()=>{ statusEl.textContent = "Triggered (no response)"; });

  // progress animation to 95% while running
  let pct = 6, ticks = 0, lastTs = 0;
  if (barEl) barEl.style.width = pct + "%";
  const tTick = setInterval(()=> {
    pct = Math.min(95, pct + 1 + Math.min(6, Math.floor(ticks/5)));
    if (barEl) barEl.style.width = pct + "%";
    ticks++;
  }, 900);

  // poll loop
  const tPoll = setInterval(async () => {
    // FAST self-heal: if our QS-derived RAW guess is live, finish immediately
    if (await getOk(rawGuessURL)) { finish(rawGuessURL); return; }

    const data = await getStatus();
    if (!data) return;

    // never show backend note
    data.note = "";

    // link to log if present
    if (data.log) {
      const logAbs = /^https?:\/\//i.test(data.log) ? data.log
                   : `${GH_PAGES_BASE}/${String(data.log).replace(/^\/+/, "")}`;
      logEl.href = bust(logAbs);
      logEl.style.display = "inline-block";
    }

    // heartbeat nudges the bar
    if (data.timestamp && data.timestamp !== lastTs) {
      lastTs = data.timestamp;
      pct = Math.min(97, pct + 2);
      if (barEl) barEl.style.width = pct + "%";
    }

    // Build candidate CSV URLs SAFELY:
    // - rawAbs is ALWAYS derived from the RELATIVE csv using the correct GH_RAW_BASE
    // - ignore malformed csv_raw in status
    const rel = data.csv ? String(data.csv).replace(/^\/+/, "") : "";
    const pagesAbs = rel ? `${GH_PAGES_BASE}/${rel}` : "";
    const rawAbs   = rel ? `${GH_RAW_BASE}/${rel}`   : "";

    // If either URL is live, we're done
    if (await getOk(rawAbs))   { finish(rawAbs);   return; }
    if (await getOk(pagesAbs)) { finish(pagesAbs); return; }

    // honor explicit error
    const phase = String(data.phase||"").toLowerCase();
    if (phase === "error") { fail(data.status||""); return; }

    // if backend claims done but we raced the CDN, still finish (download may need a second click)
    if (phase === "done" && (rawAbs || pagesAbs)) {
      finish(rawAbs || pagesAbs);
      return;
    }

    statusEl.textContent = "‚öôÔ∏è Working‚Ä¶";
  }, 900);
})();
</script>
</html>

<!-- STAMP: DSN_csv_trigger 20251030020120 -->
<div id="stamp" style="position:fixed;right:8px;bottom:8px;font:12px/1.2 monospace;color:#999;">STAMP 20251030020120</div>
