<!doctype html>
<html lang="en">
<head>
<meta charset="utf-8"/>
<title>DSN CSV Export</title>
<meta name="viewport" content="width=device-width, initial-scale=1"/>
<style>
  :root { --accent: #d00; --bg:#111; --fg:#eee; --muted:#aaa; }
  body { background:var(--bg); color:var(--fg); font:16px/1.4 system-ui, -apple-system, Segoe UI, Roboto, Helvetica, Arial, sans-serif; margin:0; padding:24px; }
  h1 { font-size:20px; margin:0 0 6px; }
  .sub { color:var(--muted); margin:0 0 16px; }
  .row { display:flex; gap:10px; align-items:center; flex-wrap:wrap; margin: 8px 0 12px; }
  a.btn, button.btn { appearance:none; border:1px solid #444; background:#222; color:#fff; padding:8px 12px; border-radius:6px; text-decoration:none; cursor:pointer; }
  a.btn[aria-disabled="true"], button.btn[disabled] { opacity:.5; cursor:not-allowed; }
  .status { margin-top:8px; min-height:1.4em; }
  .ok { color:#0f0; }
  .err { color:#f55; }
  .muted { color:var(--muted); }
  .bar-wrap { width:100%; max-width:680px; height:10px; background:#2b2b2b; border-radius:6px; overflow:hidden; margin-top:8px; }
  .bar { height:100%; width:0%; background:var(--accent); transition:width .25s linear; }
  code { background:#1a1a1a; padding:2px 4px; border-radius:4px; }
</style>
</head>
<body>
  <h1>DSN CSV Export</h1>
  <div class="sub" id="subtitle">‚Äî</div>

  <div class="row">
    <a class="btn" id="dl" aria-disabled="true" download>‚¨á Download CSV</a>
    <a class="btn" id="viewlog" aria-disabled="true" target="_blank">ü™µ View log</a>
    <button class="btn" id="retry">‚Üª Retry</button>
  </div>

  <div class="status" id="status">Preparing‚Ä¶</div>
  <div class="bar-wrap"><div class="bar" id="bar"></div></div>

<script>
(() => {
  // --- CONFIG ---------------------------------------------------------------
  // !!! Replace with your current ngrok base (no trailing slash)
  const WEBHOOK_BASE = "https://sound-kangaroo-unlikely.ngrok-free.app";

  // Pages/raw bases (do not change)
  const PAGES_BASE = "https://soazcomms.github.io/";
  const RAW_BASE   = "https://raw.githubusercontent.com/soazcomms/soazcomms.github.io/main/";

  // --- DOM refs -------------------------------------------------------------
  const subtitleEl = document.getElementById('subtitle');
  const statusEl   = document.getElementById('status');
  const barEl      = document.getElementById('bar');
  const dlEl       = document.getElementById('dl');
  const logEl      = document.getElementById('viewlog');
  const retryEl    = document.getElementById('retry');

  // --- Utils ----------------------------------------------------------------
  const qs = new URLSearchParams(location.search);
  const label = (qs.get('label')||'').trim();
  const from  = (qs.get('from') || '').trim();
  const to    = (qs.get('to')   || '').trim();

  const buster = () => Date.now().toString();
  const setBar = (pct) => { barEl.style.width = Math.max(0, Math.min(100, pct)) + "%"; };

  // Fire-and-forget logger via 1x1 pixel (no preflight)
  function turd(step, note="") {
    const u = `${WEBHOOK_BASE}/DSN_turd_pixel?step=${encodeURIComponent(step)}&note=${encodeURIComponent(note)}&label=${encodeURIComponent(label)}&from=${encodeURIComponent(from)}&to=${encodeURIComponent(to)}&bust=${buster()}`;
    const img = new Image(); img.src = u;
    // Redundant fetch GET (won‚Äôt hurt if CORS ok)
    fetch(`${WEBHOOK_BASE}/DSN_turd?step=${encodeURIComponent(step)}&note=${encodeURIComponent(note)}&label=${encodeURIComponent(label)}&from=${encodeURIComponent(from)}&to=${encodeURIComponent(to)}&bust=${buster()}`)
      .catch(()=>{ /* ignore */ });
  }

  function setStatus(html) { statusEl.innerHTML = html; }
  function enable(el, href) {
    if (href) el.href = href;
    el.removeAttribute('aria-disabled');
    el.removeAttribute('disabled');
  }
  function disable(el) {
    el.setAttribute('aria-disabled','true');
    el.setAttribute('disabled','disabled');
  }

  // Find Pages URL that exists (fallback to raw)
  async function waitForCsv(csvRel, timeoutMs = 45000) {
    const pagesUrl = PAGES_BASE + csvRel;
    const rawUrl   = RAW_BASE   + csvRel;
    const t0 = Date.now(); let tries = 0;

    while ((Date.now() - t0) < timeoutMs) {
      tries++;
      // Try Pages first
      turd('probe-pages', `try ${tries}`);
      const p = await fetch(pagesUrl + `?bust=${buster()}`, {method:'HEAD', cache:'no-store'}).catch(()=>null);
      if (p && p.ok) return {url: pagesUrl, where: 'pages'};

      // Then raw
      turd('probe-raw', `try ${tries}`);
      const r = await fetch(rawUrl + `?bust=${buster()}`, {method:'HEAD', cache:'no-store'}).catch(()=>null);
      if (r && r.ok) return {url: rawUrl, where: 'raw'};

      setStatus(`‚è≥ Waiting for CSV to go live‚Ä¶ <span class="muted">${Math.floor((Date.now()-t0)/1000)}s</span>`);
      setBar(10 + (Math.min((Date.now()-t0)/timeoutMs, 1)*60)); // fill up to ~70%
      await new Promise(res => setTimeout(res, 1500));
    }
    return {url:null, where:null};
  }

  async function fetchStatus() {
    const u = `${WEBHOOK_BASE}/DSN_status?label=${encodeURIComponent(label)}&bust=${buster()}`;
    const r = await fetch(u, {cache:'no-store'}).catch(()=>null);
    if (!r || !r.ok) return null;
    return r.json().catch(()=>null);
  }

  async function fetchLogUrl(csvLogRel) {
    const pages = PAGES_BASE + csvLogRel;
    const raw   = RAW_BASE   + csvLogRel;
    const p = await fetch(pages + `?bust=${buster()}`, {method:'HEAD'}).catch(()=>null);
    if (p && p.ok) return pages;
    const r = await fetch(raw + `?bust=${buster()}`, {method:'HEAD'}).catch(()=>null);
    if (r && r.ok) return raw;
    return null;
  }

  function autoDownload(url) {
    // Force download in all browsers with an invisible anchor
    const a = document.createElement('a');
    a.href = url;
    a.download = ''; // let server filename stand, but hint ‚Äúdownload‚Äù
    a.style.display = 'none';
    document.body.appendChild(a);
    a.click();
    setTimeout(() => a.remove(), 2000);
  }

  async function cleanupCsv(csvRel) {
    turd('cleanup-start', csvRel);
    const u = `${WEBHOOK_BASE}/DSN_cleanup?bust=${buster()}`;
    await fetch(u, {
      method: 'POST',
      headers: {'content-type': 'application/json'},
      body: JSON.stringify({csv: csvRel})
    }).catch(()=>{});
    turd('cleanup-done', csvRel);
  }

  async function run() {
    // Guardrails
    subtitleEl.textContent = `Label: ${label || '‚Äî'} ¬∑ Range: ${from || '‚Äî'} ‚Üí ${to || '‚Äî'}`;
    if (!label || !from || !to) {
      setStatus('<span class="err">‚ùå Missing label/from/to.</span>');
      disable(dlEl); disable(logEl);
      return;
    }

    // Initial UI state
    disable(dlEl); disable(logEl);
    setBar(3);
    setStatus('‚öôÔ∏è Working‚Ä¶');
    turd('html-boot');

    // Kick the job
    const kickUrl = `${WEBHOOK_BASE}/DSN_csv?bust=${buster()}`;
    turd('kick', `${label} ${from}..${to}`);
    const resp = await fetch(kickUrl, {
      method: 'POST',
      headers: {'content-type': 'application/json'},
      body: JSON.stringify({label, from, to})
    }).catch(err => ({ok:false, error: String(err)}));

    if (!resp || !resp.ok) {
      setStatus('<span class="err">‚ùå Kick failed.</span>');
      setBar(0);
      turd('kick-fail', String(resp && resp.status));
      return;
    }

    setBar(8);
    turd('kick-ok');

    // Poll status
    let csvRel = null, csvLogRel = null, done = false, t0 = Date.now();
    while (!done) {
      const st = await fetchStatus();
      if (!st || st.ok === false) { // server returned {"ok":false}
        setStatus('<span class="err">‚ùå Status error.</span>');
        turd('status-error');
        break;
      }
      // st is the JSON payload (status-*.json contents)
      if (st.phase === 'error') {
        setStatus(`<span class="err">‚ùå ${st.status || 'Error'}</span>`);
        turd('phase-error', st.status || '');
        break;
      }

      // Pull dynamic fields if present
      if (st.csv)      csvRel    = st.csv;
      if (st.log)      csvLogRel = st.log;

      // Enable log button as soon as we know its path exists anywhere
      if (csvLogRel && logEl.getAttribute('aria-disabled') === 'true') {
        const lu = await fetchLogUrl(csvLogRel);
        if (lu) enable(logEl, lu);
      }

      if (st.phase === 'done') {
        done = true;
        setBar(90);
        setStatus('‚úÖ CSV ready.');
        turd('phase-done');
        break;
      } else {
        setStatus(st.status || '‚è≥ Running‚Ä¶');
        const elapsed = Math.floor((Date.now()-t0)/1000);
        setBar(8 + Math.min(70, elapsed)); // fill steadily toward ~80%
        await new Promise(res => setTimeout(res, 1200));
      }
    }

    if (!csvRel) {
      setStatus('<span class="err">‚ùå File not found where expected.</span>');
      turd('no-csvrel');
      return;
    }

    // Wait for the CSV to be published (Pages or raw)
    const {url: liveUrl, where} = await waitForCsv(csvRel, 60000);
    if (!liveUrl) {
      setStatus('<span class="err">‚ùå CSV not visible yet (timeout).</span>');
      turd('csv-timeout', csvRel);
      return;
    }

    // Enable buttons and auto download
    enable(dlEl, liveUrl);
    if (csvLogRel) {
      const lu = await fetchLogUrl(csvLogRel);
      if (lu) enable(logEl, lu);
    }
    setBar(100);
    setStatus(`‚úÖ CSV ready via <code>${where}</code>.`);
    turd('ready', where);

    // Auto-download but keep the visible button too
    autoDownload(liveUrl);

    // After a short grace, clean up the CSV in the repo
    setTimeout(() => cleanupCsv(csvRel), 4000);
  }

  // Retry reloads the whole page (to force Grafana cache-bust)
  retryEl.addEventListener('click', () => {
    const u = new URL(location.href);
    u.searchParams.set('_', Date.now().toString());
    location.href = u.toString();
  });

  // Kick everything
  run().catch(err => {
    setStatus(`<span class="err">‚ùå ${String(err)}</span>`);
    turd('fatal', String(err));
  });
})();
</script>
</body>
</html>

<!-- STAMP: DSN_csv_trigger 20251031113837 -->
<div id="stamp" style="position:fixed;right:8px;bottom:8px;font:12px/1.2 monospace;color:#999;">STAMP 20251031113837</div>
