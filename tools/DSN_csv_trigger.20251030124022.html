<!doctype html>
<html lang="en">
<meta charset="utf-8" />
<title>DSN CSV Export</title>
<meta name="viewport" content="width=device-width,initial-scale=1" />
<style>
  body{font-family:system-ui,-apple-system,Segoe UI,Roboto,Arial,sans-serif;margin:20px;line-height:1.45}
  .wrap{max-width:780px}
  h1{margin:0 0 .5rem 0}
  .muted{color:#666}
  .row{margin:1rem 0}
  .btn{display:inline-block;padding:.6rem 1rem;border:1px solid #ddd;border-radius:8px;text-decoration:none;cursor:pointer}
  .btn.disabled{opacity:.5;pointer-events:none}
  .ok{color:#0a6}
  .err{color:#b00}
  /* keep your existing bar look */
  .bar{height:14px;background:#222;border-radius:7px;overflow:hidden;outline:2px solid #900}
  .bar>span{display:block;height:100%;width:0%;
            background:#ff1744;box-shadow:0 0 6px #ff1744,0 0 12px #ff1744;transition:width .45s ease}
  .done .bar>span{background:#18c37e;box-shadow:0 0 6px #18c37e,0 0 12px #18c37e}
  .hint{font-size:.9rem;color:#666}
</style>

<div class="wrap" id="wrap">
  <h1>DSN CSV Export</h1>
  <div class="muted" id="desc">Preparing‚Ä¶</div>

  <div class="row"><div class="bar"><span id="bar"></span></div></div>

  <div class="row">
    <a id="download" class="btn disabled" href="#">‚¨á Download CSV</a>
    <a id="viewlog" class="btn disabled" target="_blank" rel="noopener" href="#">ü™µ View log</a>
    <a id="retry" class="btn" href="#" style="display:none;">‚Üª Retry</a>
  </div>

  <div class="row muted" id="status">‚öôÔ∏è Working‚Ä¶</div>
  <div class="row hint" id="hint" style="display:none;"></div>
</div>

<script>
(() => {
  // ‚Äî‚Äî constants ‚Äî‚Äî
  const GH_PAGES_BASE = "https://soazcomms.github.io";
  const GH_RAW_BASE   = "https://raw.githubusercontent.com/soazcomms/soazcomms.github.io/main";
  const WEBHOOK_URL   = "https://sound-kangaroo-unlikely.ngrok-free.app/DSN_csv";
  const CLEANUP_URL   = "https://sound-kangaroo-unlikely.ngrok-free.app/DSN_cleanup";

  // ‚Äî‚Äî query & DOM ‚Äî‚Äî
  const qs      = new URLSearchParams(location.search);
  const label   = (qs.get("label")||"").trim();
  const fromQ   = (qs.get("from") || "").trim();
  const toQ     = (qs.get("to")   || "").trim();
  const toYMD   = s => String(s).slice(0,10).replaceAll("/","-");
  const yFrom   = toYMD(fromQ), yTo = toYMD(toQ);
  const yFromC  = yFrom.replaceAll("-",""), yToC = yTo.replaceAll("-","");
  const safeLabel = (label||"").replace(/[^\w.\-]+/g, "_");

  const wrapEl  = document.getElementById("wrap");
  const statusEl= document.getElementById("status");
  const barEl   = document.getElementById("bar");
  const dlEl    = document.getElementById("download");
  const logEl   = document.getElementById("viewlog");
  const retryEl = document.getElementById("retry");
  const descEl  = document.getElementById("desc");
  const hintEl  = document.getElementById("hint");

  descEl.textContent = `Label: ${label} ¬∑ Range: ${yFrom} ‚Üí ${yTo}`;

  // ‚Äî‚Äî helpers ‚Äî‚Äî
  const bust = u => u + (u.includes("?") ? "&" : "?") + "bust=" + Date.now();
  const setDisabled = (a, disabled=true) => {
    if (disabled) { a.classList.add("disabled"); a.setAttribute("aria-disabled","true"); }
    else { a.classList.remove("disabled"); a.removeAttribute("aria-disabled"); }
  };

  async function fetchOK(u){
    try {
      const r = await fetch(bust(u), { method:"GET", cache:"no-store", redirect:"follow" });
      return r.ok ? r : null;
    } catch { return null; }
  }
  async function firstReachable(urls){
    for (const u of urls){
      const r = await fetchOK(u);
      if (r) return { url:u, resp:r };
    }
    return null;
  }
  async function reach404(u){
    try { const r = await fetch(bust(u), { cache:"no-store", redirect:"follow" }); return r.status === 404; }
    catch { return false; }
  }

  // ‚Äî‚Äî progress bar (no visual changes) ‚Äî‚Äî
  let pct=6, ticks=0, lastTs=0;
  barEl.style.width = pct + "%";
  const tTick=setInterval(()=>{ pct=Math.min(95,pct+1+Math.min(6,Math.floor(ticks/5))); barEl.style.width=pct+"%"; ticks++; }, 900);

  // ‚Äî‚Äî initial button state: visible, disabled ‚Äî‚Äî
  setDisabled(dlEl, true);
  setDisabled(logEl, true);

  // ‚Äî‚Äî kick server job (idempotent) ‚Äî‚Äî
  fetch(WEBHOOK_URL, {
    method: "POST",
    headers: {"content-type":"application/json"},
    body: JSON.stringify({ label, from:yFrom, to:yTo })
  }).then(()=>{ statusEl.textContent = "Triggered‚Ä¶ generating CSV"; })
    .catch(()=>{ statusEl.textContent = "Triggered (no response)"; });

  // ‚Äî‚Äî expected paths ‚Äî‚Äî
  const statusRel   = `status/status-${safeLabel}.json`;
  const rawStatus   = `${GH_RAW_BASE}/${statusRel}`;
  const pagesStatus = `${GH_PAGES_BASE}/${statusRel}`;
  const expectedRel = `DSNdata/${safeLabel}_${yFromC}_${yToC}.csv`;
  const guessRAW    = `${GH_RAW_BASE}/${expectedRel}`;
  const guessPAGES  = `${GH_PAGES_BASE}/${expectedRel}`;

  // ‚Äî‚Äî poll status ‚Äî‚Äî
  let FINAL_URL = null;  // chosen live CSV URL (RAW or Pages)
  let ALT_URL   = null;  // alternate backend URL for one-shot fallback at click

  async function getStatus() {
    try { const r=await fetch(bust(rawStatus),  {cache:"no-store"}); if (r.ok) return await r.json(); } catch {}
    try { const r=await fetch(bust(pagesStatus),{cache:"no-store"}); if (r.ok) return await r.json(); } catch {}
    return null;
  }

  async function resolveLogUrl(data){
    const guess = `logs/csv-${safeLabel}-${yFromC}-${yToC}.log`;
    const candidates = [];
    if (data && data.log_raw) candidates.push(String(data.log_raw));
    if (data && data.log){
      const l = String(data.log).replace(/^\/+/, "");
      candidates.push(/^https?:\/\//i.test(l) ? l : `${GH_RAW_BASE}/${l}`);
      candidates.push(/^https?:\/\//i.test(l) ? l : `${GH_PAGES_BASE}/${l}`);
    }
    candidates.push(`${GH_RAW_BASE}/${guess}`);
    candidates.push(`${GH_PAGES_BASE}/${guess}`);
    const hit = await firstReachable(candidates);
    return hit ? hit.url : null;
  }

  function wireLog(url){
    if (!url) return;
    logEl.href = bust(url);
    setDisabled(logEl, false);
  }

  async function forceDownloadLocked(filename){
    // Try the locked URL, then one alternate attempt if 404
    const tryOnce = async (u) => {
      const r = await fetch(bust(u), { method:"GET", cache:"no-store", redirect:"follow" });
      if (!r.ok) return false;
      const blob = await r.blob();
      const objectUrl = URL.createObjectURL(blob);
      const a = document.createElement("a");
      a.href = objectUrl; a.download = filename || "data.csv";
      document.body.appendChild(a); a.click();
      setTimeout(()=>{ URL.revokeObjectURL(objectUrl); a.remove(); }, 250);
      return true;
    };

    if (FINAL_URL && await tryOnce(FINAL_URL)) return true;
    if (ALT_URL   && await tryOnce(ALT_URL))   return true;
    return false;
  }

  function finish(){
    clearInterval(tPoll); clearInterval(tTick);
    barEl.style.width = "100%"; wrapEl.classList.add("done");
    statusEl.innerHTML = '<span class="ok">‚úÖ CSV ready.</span>';
    setDisabled(dlEl, false);
    hintEl.style.display = "block";
    hintEl.textContent = "If the browser blocks the first attempt, click Download again.";
  }

  function fail(msg){
    clearInterval(tPoll); clearInterval(tTick);
    barEl.style.width = "100%";
    statusEl.innerHTML = `<span class="err">‚ùå Failed.</span> ${msg||""}`;
    retryEl.style.display="inline-block";
    retryEl.onclick=(e)=>{ e.preventDefault(); location.reload(); };
  }

  // Download click handler (locked URL + one fallback)
  dlEl.onclick = async (e)=>{
    e.preventDefault();
    if (!FINAL_URL && !ALT_URL) return;
    statusEl.textContent = "Preparing download‚Ä¶";
    const pretty = `${label}_${yFrom}_${yTo}.csv`;
    const ok = await forceDownloadLocked(pretty);
    if (!ok) { statusEl.textContent = "‚ö†Ô∏è Download failed: HTTP 404"; return; }

    // Cleanup after download
    statusEl.textContent = "üßπ Cleaning up‚Ä¶";
    const body = { label, from: yFrom, to: yTo };
    fetch(CLEANUP_URL, { method:"POST", headers:{"content-type":"application/json"}, body: JSON.stringify(body) })
      .then(r => r.json().then(j => ({ ok: r.ok, body: j })).catch(()=>({ok:r.ok, body:{}})))
      .then(async ({ ok, body })=>{
        if (!ok || body.push_ok === false) { statusEl.textContent = "‚ö†Ô∏è Cleanup push failed ‚Äî check git on server."; return; }
        const rawU = FINAL_URL?.includes(GH_RAW_BASE) ? FINAL_URL : ALT_URL?.includes(GH_RAW_BASE) ? ALT_URL : "";
        const pgU  = FINAL_URL?.includes(GH_PAGES_BASE) ? FINAL_URL : ALT_URL?.includes(GH_PAGES_BASE) ? ALT_URL : "";
        let sec=0, max=120;
        while (sec++ < max){
          const [goneRaw, gonePages] = await Promise.all([
            rawU ? reach404(rawU) : Promise.resolve(true),
            pgU  ? reach404(pgU)  : Promise.resolve(true)
          ]);
          if (goneRaw && gonePages) { statusEl.textContent = "üßπ Cleaned up."; return; }
          statusEl.textContent = `üßπ Cleaning up‚Ä¶ (${sec}s)`;
          await new Promise(res => setTimeout(res, 1000));
        }
        statusEl.textContent = "‚ö†Ô∏è Cleanup pushed; CDN may still be serving cached file.";
      })
      .catch(()=>{ statusEl.textContent = "‚ö†Ô∏è Cleanup request failed (network)."; });
  };

  // Main poll
  const tPoll = setInterval(async ()=>{
    // Early fast-path on deterministic guess (RAW or Pages)
    if (!FINAL_URL) {
      const early = await firstReachable([`${guessRAW}`, `${guessPAGES}`]);
      if (early) {
        FINAL_URL = early.url;
        ALT_URL   = (FINAL_URL.includes(GH_RAW_BASE) ? guessPAGES : guessRAW);
        finish();
      }
    }

    const statusRel = `status/status-${safeLabel}.json`;
    const data = await (async ()=>{
      try { const r=await fetch(bust(`${GH_RAW_BASE}/${statusRel}`),{cache:"no-store"}); if (r.ok) return await r.json(); } catch {}
      try { const r=await fetch(bust(`${GH_PAGES_BASE}/${statusRel}`),{cache:"no-store"}); if (r.ok) return await r.json(); } catch {}
      return null;
    })();

    if (data) {
      // enable log button when reachable
      (async () => {
        const logUrl = await resolveLogUrl(data);
        if (logUrl) wireLog(logUrl);
      })();

      if (data.timestamp && data.timestamp !== lastTs) {
        lastTs = data.timestamp; pct = Math.min(97, pct+2); barEl.style.width = pct + "%";
      }

      // lock CSV URL once we find one that is live
      if (!FINAL_URL) {
        const rel = data.csv ? String(data.csv).replace(/^\/+/, "") : "";
        const rawAbs   = data.csv_raw ? String(data.csv_raw) : (rel ? `${GH_RAW_BASE}/${rel}`   : "");
        const pagesAbs = rel ? `${GH_PAGES_BASE}/${rel}` : "";
        const hit = await firstReachable([rawAbs, pagesAbs].filter(Boolean));
        if (hit) {
          FINAL_URL = hit.url;
          ALT_URL   = FINAL_URL.includes(GH_RAW_BASE) ? pagesAbs : rawAbs;
          finish();
          return;
        }
      }

      const phase = String(data.phase||"").toLowerCase();
      if (phase === "error") { fail(data.status||""); return; }
    }

    statusEl.textContent = "‚öôÔ∏è Working‚Ä¶";
  }, 900);
})();
</script>
</html>

<!-- STAMP: DSN_csv_trigger 20251030124022 -->
<div id="stamp" style="position:fixed;right:8px;bottom:8px;font:12px/1.2 monospace;color:#999;">STAMP 20251030124022</div>
