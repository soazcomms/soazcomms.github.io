<!doctype html>
<html lang="en">
<meta charset="utf-8" />
<title>DSN CSV Export</title>
<meta name="viewport" content="width=device-width,initial-scale=1" />
<style>
  body{font-family:system-ui,-apple-system,Segoe UI,Roboto,Arial,sans-serif;margin:20px;line-height:1.45}
  .wrap{max-width:780px}
  h1{margin:0 0 .5rem 0}
  .muted{color:#666}
  .row{margin:1rem 0}
  .btn{display:inline-block;padding:.6rem 1rem;border:1px solid #ddd;border-radius:8px;text-decoration:none;cursor:pointer}
  .btn.disabled{opacity:.5;pointer-events:none}
  .ok{color:#0a6}
  .err{color:#b00}
  /* keep your existing bar look */
  .bar{height:14px;background:#222;border-radius:7px;overflow:hidden;outline:2px solid #900}
  .bar>span{display:block;height:100%;width:0%;
            background:#ff1744;box-shadow:0 0 6px #ff1744,0 0 12px #ff1744;transition:width .45s ease}
  .done .bar>span{background:#18c37e;box-shadow:0 0 6px #18c37e,0 0 12px #18c37e}
  .hint{font-size:.9rem;color:#666}
</style>

<div class="wrap" id="wrap">
  <h1>DSN CSV Export</h1>
  <div class="muted" id="desc">Preparing‚Ä¶</div>

  <div class="row"><div class="bar"><span id="bar"></span></div></div>

  <div class="row">
    <a id="download" class="btn disabled" href="#">‚¨á Download CSV</a>
    <a id="viewlog" class="btn disabled" target="_blank" rel="noopener" href="#">ü™µ View log</a>
    <a id="retry" class="btn" href="#" style="display:none;">‚Üª Retry</a>
  </div>

  <div class="row muted" id="status">‚öôÔ∏è Working‚Ä¶</div>
  <div class="row hint" id="hint" style="display:none;"></div>
</div>

<script>
(() => {
  // ‚Äî‚Äî constants ‚Äî‚Äî
  const GH_PAGES_BASE = "https://soazcomms.github.io";
  const GH_RAW_BASE   = "https://raw.githubusercontent.com/soazcomms/soazcomms.github.io/main";
  const WEBHOOK_URL   = "https://sound-kangaroo-unlikely.ngrok-free.app/DSN_csv";
  const CLEANUP_URL   = "https://sound-kangaroo-unlikely.ngrok-free.app/DSN_cleanup";

  // ‚Äî‚Äî query & DOM ‚Äî‚Äî
  const qs      = new URLSearchParams(location.search);
  const label   = (qs.get("label")||"").trim();
  const fromQ   = (qs.get("from") || "").trim();
  const toQ     = (qs.get("to")   || "").trim();
  const toYMD   = s => String(s).slice(0,10).replaceAll("/","-");
  const yFrom   = toYMD(fromQ), yTo = toYMD(toQ);
  const yFromC  = yFrom.replaceAll("-",""), yToC = yTo.replaceAll("-","");
  const safeLabel = (label||"").replace(/[^\w.\-]+/g, "_");

  const wrapEl  = document.getElementById("wrap");
  const statusEl= document.getElementById("status");
  const barEl   = document.getElementById("bar");
  const dlEl    = document.getElementById("download");
  const logEl   = document.getElementById("viewlog");
  const retryEl = document.getElementById("retry");
  const descEl  = document.getElementById("desc");
  const hintEl  = document.getElementById("hint");

  descEl.textContent = `Label: ${label} ¬∑ Range: ${yFrom} ‚Üí ${yTo}`;

  // ‚Äî‚Äî helpers ‚Äî‚Äî
  const bust = u => u + (u.includes("?") ? "&" : "?") + "bust=" + Date.now();
  const setDisabled = (a, disabled=true) => {
    if (disabled) { a.classList.add("disabled"); a.setAttribute("aria-disabled","true"); }
    else { a.classList.remove("disabled"); a.removeAttribute("aria-disabled"); }
  };

  async function reach404(u){
    try { const r = await fetch(bust(u), { cache:"no-store", redirect:"follow" }); return r.status === 404; }
    catch { return false; }
  }

  // ‚Äî‚Äî progress bar (no visual changes) ‚Äî‚Äî
  let pct=6, ticks=0, lastTs=0;
  barEl.style.width = pct + "%";
  const tTick=setInterval(()=>{ pct=Math.min(95,pct+1+Math.min(6,Math.floor(ticks/5))); barEl.style.width=pct+"%"; ticks++; }, 900);

  // ‚Äî‚Äî initial state: buttons visible, disabled ‚Äî‚Äî
  setDisabled(dlEl, true);
  setDisabled(logEl, true);

  // ‚Äî‚Äî kick server job (idempotent) ‚Äî‚Äî
  fetch(WEBHOOK_URL, {
    method: "POST",
    headers: {"content-type":"application/json"},
    body: JSON.stringify({ label, from:yFrom, to:yTo })
  }).then(()=>{ statusEl.textContent = "Triggered‚Ä¶ generating CSV"; })
    .catch(()=>{ statusEl.textContent = "Triggered (no response)"; });

  // ‚Äî‚Äî expected relative paths (for fallback building) ‚Äî‚Äî
  const statusRel   = `status/status-${safeLabel}.json`;
  const expectedRel = `DSNdata/${safeLabel}_${yFromC}_${yToC}.csv`;

  // Final choices for this run (we do NOT pre-probe them to avoid CORS hangs)
  let FINAL_URLS = [];   // download attempts in order
  let LOG_URL    = null; // when present, we enable the log button

  // Wire download: try the known-good list in order, no pre-probe
  dlEl.onclick = async (e)=>{
    e.preventDefault();
    if (!FINAL_URLS.length) return;
    statusEl.textContent = "Preparing download‚Ä¶";

    // Download via Blob (forces Save dialog / downloads bar)
    const tryOnce = async (u, pretty) => {
      try{
        const r = await fetch(bust(u), { method:"GET", cache:"no-store", redirect:"follow" });
        if (!r.ok) return false;
        const blob = await r.blob();
        const objectUrl = URL.createObjectURL(blob);
        const a = document.createElement("a");
        a.href = objectUrl; a.download = pretty;
        document.body.appendChild(a); a.click();
        setTimeout(()=>{ URL.revokeObjectURL(objectUrl); a.remove(); }, 250);
        return true;
      }catch{ return false; }
    };

    const pretty = `${label}_${yFrom}_${yTo}.csv`;
    let ok = false;
    for (const u of FINAL_URLS) {
      ok = await tryOnce(u, pretty);
      if (ok) break;
    }
    if (!ok) { statusEl.textContent = "‚ö†Ô∏è Download failed: HTTP 404"; return; }

    // Cleanup after download
    statusEl.textContent = "üßπ Cleaning up‚Ä¶";
    const body = { label, from: yFrom, to: yTo };
    fetch(CLEANUP_URL, { method:"POST", headers:{"content-type":"application/json"}, body: JSON.stringify(body) })
      .then(r => r.json().then(j => ({ ok: r.ok, body: j })).catch(()=>({ok:r.ok, body:{}})))
      .then(async ({ ok, body })=>{
        if (!ok || body.push_ok === false) { statusEl.textContent = "‚ö†Ô∏è Cleanup push failed ‚Äî check git on server."; return; }

        // Verify disappearance on both backends (bounded)
        const rawU   = FINAL_URLS.find(u => u.startsWith(GH_RAW_BASE))   || `${GH_RAW_BASE}/${expectedRel}`;
        const pagesU = FINAL_URLS.find(u => u.startsWith(GH_PAGES_BASE)) || `${GH_PAGES_BASE}/${expectedRel}`;
        let sec=0, max=120;
        while (sec++ < max){
          const [goneRaw, gonePages] = await Promise.all([
            rawU ? reach404(rawU) : Promise.resolve(true),
            pagesU ? reach404(pagesU) : Promise.resolve(true)
          ]);
          if (goneRaw && gonePages) { statusEl.textContent = "üßπ Cleaned up."; return; }
          statusEl.textContent = `üßπ Cleaning up‚Ä¶ (${sec}s)`;
          await new Promise(res => setTimeout(res, 1000));
        }
        statusEl.textContent = "‚ö†Ô∏è Cleanup pushed; CDN may still be serving cached file.";
      })
      .catch(()=>{ statusEl.textContent = "‚ö†Ô∏è Cleanup request failed (network)."; });
  };

  // Poll ONLY the status JSON. No CSV/log pre-probing (avoids CORS stalls).
  const tPoll = setInterval(async ()=>{
    // Prefer RAW status, then Pages
    const fetchStatus = async (u) => {
      try { const r = await fetch(bust(u), {cache:"no-store"}); if (r.ok) return await r.json(); }
      catch {}
      return null;
    };
    const data = await (async () => {
      const rawU = `${GH_RAW_BASE}/${statusRel}`;
      const pgU  = `${GH_PAGES_BASE}/${statusRel}`;
      return (await fetchStatus(rawU)) || (await fetchStatus(pgU));
    })();

    if (!data) { statusEl.textContent = "‚öôÔ∏è Working‚Ä¶"; return; }

    // enable log button as soon as we have *any* URL candidate (no pre-probe)
    if (!LOG_URL) {
      LOG_URL = data.log_raw || (data.log ? (/^https?:\/\//i.test(data.log) ? data.log : `${GH_PAGES_BASE}/${String(data.log).replace(/^\/+/, "")}`) : null);
      if (!LOG_URL) {
        const guess = `logs/csv-${safeLabel}-${yFromC}-${yToC}.log`;
        LOG_URL = `${GH_RAW_BASE}/${guess}`;
      }
      logEl.href = bust(LOG_URL);
      setDisabled(logEl, false);
    }

    if (data.timestamp && data.timestamp !== lastTs) {
      lastTs = data.timestamp; pct = Math.min(97, pct+2); barEl.style.width = pct + "%";
    }

    const phase = String(data.phase||"").toLowerCase();

    if (phase === "done") {
      // Build the ordered list of download attempts (no probing here)
      const rel = data.csv ? String(data.csv).replace(/^\/+/, "") : expectedRel;
      const ordered = [
        data.csv_raw,                              // explicit RAW from server, best
        `${GH_PAGES_BASE}/${rel}`,                 // Pages explicit/relative
        `${GH_RAW_BASE}/${expectedRel}`,           // guess RAW
        `${GH_PAGES_BASE}/${expectedRel}`          // guess Pages
      ].filter(Boolean);
      FINAL_URLS = Array.from(new Set(ordered));   // de-dup
      clearInterval(tPoll); clearInterval(tTick);
      barEl.style.width = "100%"; wrapEl.classList.add("done");
      statusEl.innerHTML = '<span class="ok">‚úÖ CSV ready.</span>';
      setDisabled(dlEl, false);
      hintEl.style.display = "block";
      hintEl.textContent = "If the browser blocks the first attempt, click Download again.";
      return;
    }

    if (phase === "error") {
      clearInterval(tPoll); clearInterval(tTick);
      barEl.style.width = "100%";
      statusEl.innerHTML = `<span class="err">‚ùå Failed.</span> ${data.status||""}`;
      retryEl.style.display="inline-block";
      retryEl.onclick=(e)=>{ e.preventDefault(); location.reload(); };
      return;
    }

    statusEl.textContent = "‚öôÔ∏è Working‚Ä¶";
  }, 900);
})();
</script>
</html>

<!-- STAMP: DSN_csv_trigger 20251030125228 -->
<div id="stamp" style="position:fixed;right:8px;bottom:8px;font:12px/1.2 monospace;color:#999;">STAMP 20251030125228</div>
