<!doctype html>
<html lang="en">
<meta charset="utf-8" />
<title>DSN CSV Export</title>
<meta name="viewport" content="width=device-width,initial-scale=1" />
<style>
  body{font-family:system-ui,-apple-system,Segoe UI,Roboto,Arial,sans-serif;margin:20px;line-height:1.45}
  .wrap{max-width:780px}
  h1{margin:0 0 .5rem 0}
  .muted{color:#666}
  .row{margin:1rem 0}
  .btn{display:inline-block;padding:.6rem 1rem;border:1px solid #ddd;border-radius:8px;text-decoration:none;cursor:pointer}
  .btn.disabled{opacity:.5;pointer-events:none}
  .ok{color:#0a6}
  .err{color:#b00}
  /* keep your existing bar look/size/colors */
  .bar{height:14px;background:#222;border-radius:7px;overflow:hidden;outline:2px solid #900}
  .bar>span{display:block;height:100%;width:0%;
            background:#ff1744;box-shadow:0 0 6px #ff1744,0 0 12px #ff1744;transition:width .45s ease}
  .done .bar>span{background:#18c37e;box-shadow:0 0 6px #18c37e,0 0 12px #18c37e}
  .hint{font-size:.9rem;color:#666}
</style>

<div class="wrap" id="wrap">
  <h1>DSN CSV Export</h1>
  <div class="muted" id="desc">Preparing‚Ä¶</div>

  <div class="row"><div class="bar"><span id="bar"></span></div></div>

  <div class="row">
    <a id="download" class="btn disabled" href="#">‚¨á Download CSV</a>
    <a id="viewlog" class="btn disabled" target="_blank" rel="noopener" href="#">ü™µ View log</a>
    <a id="retry"   class="btn" href="#" style="display:none;">‚Üª Retry</a>
  </div>

  <div class="row muted" id="status">‚öôÔ∏è Working‚Ä¶</div>
  <div class="row hint"   id="hint" style="display:none;"></div>
</div>

<script>
(() => {
  // --- endpoints (match your webhook/ngrok & GH pages) ---
  const GH_PAGES_BASE = "https://soazcomms.github.io";
  const GH_RAW_BASE   = "https://raw.githubusercontent.com/soazcomms/soazcomms.github.io/main";
  const WEBHOOK_URL   = "https://sound-kangaroo-unlikely.ngrok-free.app/DSN_csv";
  const CLEANUP_URL   = "https://sound-kangaroo-unlikely.ngrok-free.app/DSN_cleanup";

  // --- query params from Grafana ---
  const qs      = new URLSearchParams(location.search);
  const label   = (qs.get("label")||"").trim();
  const fromQ   = (qs.get("from") || "").trim();
  const toQ     = (qs.get("to")   || "").trim();

  // --- dom ---
  const wrapEl  = document.getElementById("wrap");
  const statusEl= document.getElementById("status");
  const barFill = document.getElementById("bar");
  const dlEl    = document.getElementById("download");
  const logEl   = document.getElementById("viewlog");
  const retryEl = document.getElementById("retry");
  const descEl  = document.getElementById("desc");
  const hintEl  = document.getElementById("hint");

  // --- formatting helpers ---
  const toYMD = s => String(s).slice(0,10).replaceAll("/","-");
  const yFrom = toYMD(fromQ), yTo = toYMD(toQ);
  const yFromC = yFrom.replaceAll("-","");
  const yToC   = yTo.replaceAll("-","");
  const safeLabel = (label||"").replace(/[^\w.\-]+/g, "_");
  descEl.textContent = `Label: ${label} ¬∑ Range: ${yFrom} ‚Üí ${yTo}`;

  const bust = u => u + (u.includes("?") ? "&" : "?") + "bust=" + Date.now();
  const setDisabled = (a, dis=true) => {
    if (dis) { a.classList.add("disabled"); a.setAttribute("aria-disabled","true"); }
    else     { a.classList.remove("disabled"); a.removeAttribute("aria-disabled"); }
  };
  const toAbs = (maybe, base) => {
    if (!maybe) return null;
    if (/^https?:\/\//i.test(maybe)) return maybe;
    return base.replace(/\/+$/,"") + "/" + String(maybe).replace(/^\/+/,"");
  };

  // --- progress bar (unchanged visuals) ---
  let pct=8, ticks=0;
  barFill.style.width = pct + "%";
  const tTick = setInterval(() => {
    pct = Math.min(95, pct + 1 + Math.min(6, Math.floor(ticks/5)));
    barFill.style.width = pct + "%";
    ticks++;
  }, 900);

  // --- status sources (RAW first for freshness; fallback to Pages) ---
  const statusRel = `status/status-${safeLabel}.json`;
  const rawStatus = `${GH_RAW_BASE}/${statusRel}`;
  const pgStatus  = `${GH_PAGES_BASE}/${statusRel}`;
  async function getStatus() {
    try { const r = await fetch(bust(rawStatus), {cache:"no-store"}); if (r.ok) return await r.json(); } catch {}
    try { const r = await fetch(bust(pgStatus),  {cache:"no-store"}); if (r.ok) return await r.json(); } catch {}
    return null;
  }

  // --- creation: tell webhook to build/push CSV for this label/range ---
  fetch(WEBHOOK_URL, {
    method:"POST",
    headers:{"content-type":"application/json"},
    body: JSON.stringify({ label, from: yFrom, to: yTo })
  }).catch(()=>{}); // silent ‚Äî we poll status below regardless

  // --- derive CSV + LOG candidates from status (or guesses if status lags) ---
  function csvCandidatesFrom(data){
    const rel = data && data.csv ? String(data.csv).replace(/^\/+/,"")
                                 : `DSNdata/${safeLabel}_${yFromC}_${yToC}.csv`;
    const urls = [];
    if (data && data.csv_raw) urls.push(String(data.csv_raw));
    urls.push(`${GH_RAW_BASE}/${rel}`);                // raw first (fastest propagation)
    urls.push(`${GH_PAGES_BASE}/${rel}`);              // pages fallback
    return { rel, urls: Array.from(new Set(urls)) };
  }
  function logCandidatesFrom(data){
    const rel = data && data.log ? String(data.log).replace(/^\/+/,"")
                                 : `logs/csv-${safeLabel}-${yFromC}-${yToC}.log`;
    const urls = [];
    if (data && data.log_raw) urls.push(String(data.log_raw));
    urls.push(`${GH_RAW_BASE}/${rel}`);
    urls.push(`${GH_PAGES_BASE}/${rel}`);
    return { rel, urls: Array.from(new Set(urls)) };
  }

  // --- post-download cleanup: delete CSV via webhook (git rm + commit + push) ---
  async function postCleanup(csvRelPath) {
    try {
      const payload = JSON.stringify({ csv: String(csvRelPath||"").replace(/^\/+/,"") });
      const blob = new Blob([payload], { type: "application/json" });
      // sendBeacon ensures it fires even if the browser navigates
      if (navigator.sendBeacon && navigator.sendBeacon(CLEANUP_URL, blob)) return;
      await fetch(CLEANUP_URL, { method:"POST", headers:{ "Content-Type":"application/json" }, body: payload });
    } catch {}
  }

  // --- enable buttons when file/log are truly reachable ---
  function enableLog(url) {
    logEl.href = bust(url);
    setDisabled(logEl, false);
  }

  function enableDownload(candidateUrls, csvRelPath) {
    setDisabled(dlEl, false);
    dlEl.onclick = async (e) => {
      e.preventDefault();
      statusEl.textContent = "Preparing download‚Ä¶";
      const pretty = `${safeLabel}_${yFrom}_${yTo}.csv`;

      // Try RAW first, then any other candidates
      for (const u of candidateUrls) {
        try {
          const r = await fetch(bust(u), { method:"GET", cache:"no-store", redirect:"follow" });
          if (!r.ok) continue;

          const blob = await r.blob();
          const obj  = URL.createObjectURL(blob);

          // Start the real download
          const a = document.createElement("a");
          a.href = obj;
          a.download = pretty;
          document.body.appendChild(a);
          a.click();
          a.remove();

          // Cleanup after download begins
          setTimeout(()=> postCleanup(csvRelPath), 1200);

          // Finish UI
          clearInterval(tTick);
          wrapEl.classList.add("done");
          barFill.style.width="100%";
          statusEl.innerHTML = '<span class="ok">‚úÖ CSV downloaded.</span>';
          hintEl.style.display="block";
          hintEl.textContent = "If the browser blocks the first attempt, click Download again.";
          setTimeout(()=> URL.revokeObjectURL(obj), 1500);
          return;
        } catch {}
      }
      statusEl.innerHTML = `‚ö†Ô∏è Download failed: HTTP 404`;
    };
  }

  // --- existence probe (HEAD), used when status lags but file is live ---
  async function firstReachable(urls){
    for (const u of urls) {
      try {
        const r = await fetch(bust(u), { method:"HEAD", cache:"no-store", redirect:"follow" });
        if (r && r.ok) return u;
      } catch {}
    }
    return null;
  }

  // --- polling loop: prefer status.json; fall back to probing CSV/log; hard fail if nothing ---
  const STARTED   = Date.now();
  const PROBE_AFTER_MS = 8000;  // start probing for the file after 8s
  const PROBE_EVERY_MS = 3000;  // probe cadence
  const HARD_FAIL_MS   = 60000; // stop hanging forever

  let lastProbe=0, lastTs=0, ready=false;

  const tPoll = setInterval(async () => {
    if (ready) return;

    // progress nudge
    barFill.style.width = Math.min(97, (Date.now()-STARTED)/HARD_FAIL_MS*90 + 7) + "%";

    // 1) Try status.json (RAW then Pages)
    const data = await getStatus();

    if (data && data.timestamp && data.timestamp !== lastTs) {
      lastTs = data.timestamp;
      barFill.style.width = Math.min(97, parseFloat(barFill.style.width) + 2) + "%";
    }

    if (data && (String(data.phase).toLowerCase() === "done" || String(data.status).toLowerCase().includes("ready"))) {
      // arm from authoritative status
      const cc = csvCandidatesFrom(data);
      const lc = logCandidatesFrom(data);
      const foundCSV = await firstReachable(cc.urls);
      if (foundCSV) {
        clearInterval(tPoll); clearInterval(tTick);
        wrapEl.classList.add("done"); barFill.style.width="100%";
        statusEl.innerHTML = '<span class="ok">‚úÖ CSV ready.</span>';
        enableDownload([foundCSV, ...cc.urls.filter(u=>u!==foundCSV)], cc.rel);
        const foundLOG = await firstReachable(lc.urls);
        if (foundLOG) enableLog(foundLOG);
        ready = true;
        return;
      }
    }

    // 2) If status lags, after a short delay probe for CSV directly
    if ((Date.now()-STARTED) >= PROBE_AFTER_MS && (Date.now()-lastProbe) >= PROBE_EVERY_MS) {
      lastProbe = Date.now();
      const cc = csvCandidatesFrom(data || {});
      const found = await firstReachable(cc.urls);
      if (found) {
        clearInterval(tPoll); clearInterval(tTick);
        wrapEl.classList.add("done"); barFill.style.width="100%";
        statusEl.innerHTML = '<span class="ok">‚úÖ CSV ready.</span>';
        enableDownload([found, ...cc.urls.filter(u=>u!==found)], cc.rel);

        const lc = logCandidatesFrom(data || {});
        const foundLOG = await firstReachable(lc.urls);
        if (foundLOG) enableLog(foundLOG);
        ready = true;
        return;
      }
    }

    // 3) Hard stop to avoid infinite hang
    if ((Date.now()-STARTED) >= HARD_FAIL_MS) {
      clearInterval(tPoll); clearInterval(tTick);
      barFill.style.width="100%";
      statusEl.innerHTML = `<span class="err">‚ùå File not found where expected.</span>`;
      retryEl.style.display="inline-block";
      retryEl.onclick = (e)=>{ e.preventDefault(); location.reload(); };
    }
  }, 900);
})();
</script>
</html>

<!-- STAMP: DSN_csv_trigger 20251030163210 -->
<div id="stamp" style="position:fixed;right:8px;bottom:8px;font:12px/1.2 monospace;color:#999;">STAMP 20251030163210</div>
