<!doctype html>
<meta charset="utf-8" />
<title>DSN CSV Export</title>
<style>
  body { font: 14px/1.4 system-ui, -apple-system, Segoe UI, Roboto, sans-serif; margin: 22px; }
  h1 { margin: 0 0 8px 0; font-size: 18px; }
  .meta { color: #555; margin-bottom: 12px; }
  .row { display: flex; gap: 10px; align-items: center; margin: 10px 0; }
  a.btn, button.btn {
    padding: 6px 10px; border: 1px solid #bbb; border-radius: 6px; text-decoration: none;
    color: #111; background: #f7f7f7; cursor: pointer;
  }
  a.btn[aria-disabled="true"], button.btn[aria-disabled="true"] { opacity: .45; pointer-events: none; }
  .status { margin-top: 10px; }
  .bar {
    position: relative; width: 420px; height: 10px; background: #eee; border-radius: 5px; overflow: hidden;
    display: inline-block; vertical-align: middle; margin-left: 8px;
  }
  .bar > span {
    position: absolute; left: 0; top: 0; bottom: 0; width: 0%;
    background: #d33; /* visible red as requested earlier */
    transition: width .25s linear;
  }
  .ok { color: #0a7a0a; font-weight: 600; }
  .err { color: #b00020; font-weight: 600; }
  .note { color: #444; font-style: italic; margin-left: 6px; }
  code.small { font-size: 12px; color: #666; }
  iframe#dl_iframe { display: none; }
</style>

<h1>DSN CSV Export</h1>
<div class="meta" id="meta"></div>
<div class="row">
  <a id="btnDownload" class="btn" href="#" aria-disabled="true" download>‚¨á Download CSV</a>
  <a id="btnLog" class="btn" href="#" aria-disabled="true" target="_blank" rel="noopener">ü™µ View log</a>
  <button id="btnRetry" class="btn" aria-disabled="true">‚Üª Retry</button>
</div>
<div class="status" id="status">‚öôÔ∏è Working‚Ä¶<span class="bar"><span id="barFill"></span></span></div>
<iframe id="dl_iframe"></iframe>

<script>
(function(){
  // --- Inputs ---
  const qs = new URLSearchParams(location.search);
  const label = qs.get("label") || "";
  const from  = (qs.get("from") || "").slice(0,10);
  const to    = (qs.get("to")   || "").slice(0,10);

  // --- Constants (RAW first for status) ---
  const PAGES_BASE = "https://soazcomms.github.io/";
  const RAW_BASE   = "https://raw.githubusercontent.com/soazcomms/soazcomms.github.io/main/";

  const metaEl   = document.getElementById("meta");
  const statusEl = document.getElementById("status");
  const barFill  = document.getElementById("barFill");
  const aDL      = document.getElementById("btnDownload");
  const aLOG     = document.getElementById("btnLog");
  const btnRetry = document.getElementById("btnRetry");
  const dlFrame  = document.getElementById("dl_iframe");

  // Paint header/meta
  const nice = (s) => s ? s : "‚Äî";
  metaEl.textContent = `Label: ${nice(label)} ¬∑ Range: ${nice(from)} ‚Üí ${nice(to)}`;

  // Utility
  const bust = () => `bust=${Date.now()}${Math.random().toString(16).slice(2)}`;
  const sleep = (ms) => new Promise(r => setTimeout(r, ms));

  // Progress animation (keeps moving so it never looks dead)
  let t0 = performance.now();
  let animId = null;
  const animate = () => {
    const t = (performance.now() - t0) / 1000;
    // sawtooth 0..100% every ~6s
    const pct = ( (t % 6) / 6 ) * 100;
    barFill.style.width = `${pct}%`;
    animId = requestAnimationFrame(animate);
  };
  animate();

  // Buttons initial state
  const disable = (el, v=true) => el.setAttribute("aria-disabled", v ? "true" : "false");
  disable(aDL,  true);
  disable(aLOG, true);
  disable(btnRetry, true);

  // ---- Status polling (RAW first to avoid Pages lag) ----
  const statusPath = `status/status-${encodeURIComponent(label)}.json`;
  const statusRAW  = RAW_BASE + statusPath;

  async function fetchStatusOnce() {
    try {
      const r = await fetch(`${statusRAW}?${bust()}`, {cache:"no-store"});
      if (!r.ok) return null;
      return await r.json();
    } catch { return null; }
  }

  // ---- CSV HEAD check: try Pages first, then Raw ----
  async function csvIsReady(relPath) {
    const urlPages = PAGES_BASE + relPath.replace(/^\/+/, "");
    const urlRaw   = RAW_BASE   + relPath.replace(/^\/+/, "");
    // Pages first (preferred), then raw
    try {
      const rp = await fetch(`${urlPages}?${bust()}`, {method:"HEAD", cache:"no-store"});
      if (rp.ok) return {ok:true, where:"pages", url:urlPages};
    } catch {}
    try {
      const rr = await fetch(`${urlRaw}?${bust()}`, {method:"HEAD", cache:"no-store"});
      if (rr.ok) return {ok:true, where:"raw", url:urlRaw};
    } catch {}
    return {ok:false};
  }

  // ---- LOG HEAD check (RAW is fine) ----
  async function logIsReady(relPath) {
    const url = RAW_BASE + relPath.replace(/^\/+/, "");
    try {
      const r = await fetch(`${url}?${bust()}`, {method:"HEAD", cache:"no-store"});
      return r.ok ? {ok:true, url} : {ok:false};
    } catch { return {ok:false}; }
  }

  // ---- Trigger the job if not already running/done ----
  async function triggerIfNeeded() {
    // Post to webhook; ignore if already running server-side
    try {
      await fetch("/DSN_csv", { // same origin in ngrok; but we‚Äôre loading from Pages, so use public webhook?
        method: "POST", headers: {"Content-Type":"application/json"},
        body: JSON.stringify({label, from, to})
      });
    } catch (e) {
      // If you‚Äôre serving this from Pages, the above won‚Äôt work; you‚Äôre already running the job from Grafana.
      // That‚Äôs OK‚Äîstatus polling below will still converge once status JSON is pushed.
    }
  }

  // ---- Main loop ----
  (async function main(){
    // kick the job optimistically
    triggerIfNeeded();

    let csvRel = "";
    let logRel = "";
    let ready  = false;

    for (let i=0; i<300; i++) { // up to ~5 min
      const st = await fetchStatusOnce();

      if (st && st.phase === "done") {
        csvRel = st.csv || "";
        logRel = st.log || "";
        statusEl.innerHTML = `<span class="ok">‚úÖ CSV ready.</span> <span class="note">(source: ${st.csv_pages ? 'Pages' : 'RAW'})</span> <span class="bar"><span id="barFill"></span></span>`;
        // progress bar at 100%
        barFill.style.width = "100%";

        // Check actual availability now (either Pages or RAW) and wire the download + log
        let href = "";
        if (csvRel) {
          const chk = await csvIsReady(csvRel);
          if (chk.ok) href = chk.url;
        }
        if (href) {
          // Enable Download (force a download via hidden iframe; also set download attribute)
          aDL.href = href;
          aDL.setAttribute("download", (csvRel.split("/").pop() || "data.csv"));
          disable(aDL, false);

          aDL.onclick = async (ev) => {
            ev.preventDefault();
            // Hidden iframe fetch; most browsers will download
            dlFrame.src = `${href}?${bust()}`;
            // Schedule cleanup after a short delay (delete after download)
            scheduleCleanup();
          };
          ready = true;
        } else {
          statusEl.innerHTML = `‚úÖ CSV ready, but CDN not visible yet ‚Äî retrying short polls‚Ä¶ <span class="bar"><span id="barFill"></span></span>`;
        }

        if (logRel) {
          const lchk = await logIsReady(logRel);
          if (lchk.ok) {
            aLOG.href = lchk.url;
            disable(aLOG, false);
          }
        }

        if (ready) {
          disable(btnRetry, false);
          cancelAnimationFrame(animId);
          return;
        }
      }
      else if (st && st.phase === "error") {
        const msg = st.status || "unknown error";
        statusEl.innerHTML = `<span class="err">‚ùå ${msg}</span> <span class="bar"><span id="barFill"></span></span>`;
        // still try to light up the log if present
        if (st.log) {
          const lchk = await logIsReady(st.log);
          if (lchk.ok) { aLOG.href = lchk.url; disable(aLOG, false); }
        }
        disable(btnRetry, false);
        cancelAnimationFrame(animId);
        return;
      }
      else {
        // running or no status yet
        statusEl.innerHTML = `‚öôÔ∏è Working‚Ä¶ <span class="bar"><span id="barFill"></span></span>`;
      }

      await sleep(1000);
    }

    statusEl.innerHTML = `<span class="err">‚è≥ Timed out waiting for CSV.</span> <span class="bar"><span id="barFill"></span></span>`;
    disable(btnRetry, false);
    cancelAnimationFrame(animId);
  })();

  // ---- Cleanup (after user clicks Download) ----
  async function scheduleCleanup(){
    // Give the browser time to start download
    await sleep(4000);
    try {
      await fetch("/DSN_cleanup", {
        method: "POST",
        headers: {"Content-Type":"application/json"},
        body: JSON.stringify({label, from, to})
      });
    } catch(e) {
      // ignore; cleanup can be manual if webhook isn‚Äôt locally reachable from Pages
    }
  }

  // Retry simply reloads with a fresh cache-buster
  btnRetry.onclick = () => {
    if (btnRetry.getAttribute("aria-disabled")==="true") return;
    const u = new URL(location.href);
    u.searchParams.set("_", String(Date.now()));
    location.href = u.toString();
  };
})();
</script>

<!-- STAMP: DSN_csv_trigger 20251030144420 -->
<div id="stamp" style="position:fixed;right:8px;bottom:8px;font:12px/1.2 monospace;color:#999;">STAMP 20251030144420</div>
