<!DOCTYPE html>
<html lang="en">
<head>
  <meta charset="utf-8">
  <title>DSN Analysis</title>
  <meta name="viewport" content="width=device-width, initial-scale=1" />
  <style>
    body {
      font-family: system-ui, -apple-system, BlinkMacSystemFont, sans-serif;
      background: #05060a;
      color: #eee;
      margin: 0;
      padding: 1rem 1.5rem;
    }
    h1 {
      font-size: 1.3rem;
      margin: 0 0 0.4rem 0;
    }
    .site {
      font-size: 0.95rem;
      margin-bottom: 0.75rem;
      color: #aaa;
    }
    .status {
      margin: 0.6rem 0 0.2rem 0;
      min-height: 1.4rem;
    }
    .row {
      margin-top: 0.4rem;
      display: flex;
      align-items: center;
      gap: 0.75rem;
      font-size: 0.9rem;
    }
    .btn {
      display: inline-block;
      padding: 0.35rem 0.8rem;
      font-size: 0.9rem;
      border-radius: 999px;
      border: 1px solid #3b82f6;
      background: #0b1120;
      color: #e5e7eb;
      text-decoration: none;
      cursor: pointer;
      transition: background 0.15s ease, color 0.15s ease, border-color 0.15s ease;
    }
    .btn[disabled] {
      opacity: 0.4;
      cursor: default;
    }
    .btn:not([disabled]):hover {
      background: #1d4ed8;
      color: white;
    }
    .timer {
      font-variant-numeric: tabular-nums;
      font-size: 0.85rem;
      color: #a5b4fc;
    }
    .bar-wrap {
      margin-top: 0.6rem;
      margin-bottom: 0.2rem;
      width: 100%;
      max-width: 360px;
    }
    .bar {
      position: relative;
      width: 100%;
      height: 0.4rem;
      border-radius: 999px;
      background: rgba(148, 163, 184, 0.25);
      overflow: hidden;
    }
    .bar-fill {
      width: 0%;
      height: 100%;
      border-radius: inherit;
      background: linear-gradient(90deg, #60a5fa, #22c55e);
      transition: width 0.3s linear;  /* smooth fill */
    }
    .err {
      color: #fecaca;
    }
    .ok {
      color: #bbf7d0;
    }
  </style>
</head>
<body>
  <h1>üî¨ DSN Analysis V.37</h1>
  <div id="site" class="site"></div>

  <div class="status" id="status">‚è≥ Initializing‚Ä¶</div>

  <div id="barRow" class="bar-wrap">
    <div class="bar"><div class="bar-fill"></div></div>
  </div>

  <div id="timerRow" class="row">
    <div class="timer">
      ‚è± <span id="elapsed">0:00</span> ¬∑ Timeout in <span id="remaining">7:00</span>
    </div>
  </div>

  <div class="row">
    <a id="viewBtn" class="btn" href="#" target="_blank" rel="noopener" disabled>üìÑ View Analysis Result</a>
    <a id="exitBtn" class="btn" href="#" onclick="closeTab()">üîô Exit</a>
  </div>

  <script>
  // Make this tab script-owned so window.close() will work
  if (!window.name) {
    window.name = "dsn_cf_trigger";
    window.open(window.location.href, "_self");
  }
  function closeTab() {
    window.close();
  }
  </script>
<script>
(function () {
  // ---- DOM refs ----
  const statusEl = document.getElementById("status");
  const timerEl  = document.getElementById("timer");
  const viewBtn  = document.getElementById("viewBtn");

  // ---- Query params ----
  const params   = new URLSearchParams(window.location.search);
  const rawLabel = (params.get("label") || "").trim();
  const fromTxt  = (params.get("from")  || "").trim();
  const toTxt    = (params.get("to")    || "").trim();

  // ---- Constants ----
  const WORKER_URL    = "https://dsn-analysis.dsn-analysis.workers.dev/";
  const GH_RAW_BASE   = "https://raw.githubusercontent.com/soazcomms/soazcomms.github.io/main/";
  const GH_PAGES_BASE = "https://soazcomms.github.io/";

  // status file: status/status-<label>.json
  const STATUS_URL =
    `${GH_RAW_BASE}status/status-${encodeURIComponent(rawLabel)}.json`;

  // default final HTML if status.html is missing
  const DEFAULT_FINAL_HTML =
    `${GH_PAGES_BASE}analysis/${encodeURIComponent(rawLabel)}/${encodeURIComponent(rawLabel)}.analysis.html`;

  // ---- timers & state ----
  let startedAt      = Date.now();
  let pollTimerId    = null;
  let elapsedTimerId = null;
  let firstStatusSeen = false;
  let finished       = false;
  const TIMEOUT_MS   = 7 * 60 * 1000; // 7 minutes

  function stopAllTimers() {
    if (pollTimerId) {
      clearTimeout(pollTimerId);
      pollTimerId = null;
    }
    if (elapsedTimerId) {
      clearInterval(elapsedTimerId);
      elapsedTimerId = null;
    }
  }

  function startElapsedTimer() {
    if (!timerEl) return;
    elapsedTimerId = setInterval(() => {
      const delta = Date.now() - startedAt;
      const secs  = Math.floor(delta / 1000);
      const mm    = String(Math.floor(secs / 60)).padStart(1, "0");
      const ss    = String(secs % 60).padStart(2, "0");
      const remain = Math.max(0, TIMEOUT_MS - delta);
      const rsecs   = Math.floor(remain / 1000);
      const rmm     = String(Math.floor(rsecs / 60)).padStart(1, "0");
      const rss     = String(rsecs % 60).padStart(2, "0");
      timerEl.textContent = `‚è± ${mm}:${ss} ¬∑ Timeout in ${rmm}:${rss}`;
    }, 1000);
  }

  function setStatus(msg) {
    if (statusEl) statusEl.textContent = msg;
  }

  function showDone(msg, href) {
    finished = true;
    const m = msg || `‚úÖ Analysis complete for ${rawLabel}`;
    setStatus(m);
    if (viewBtn) {
      viewBtn.removeAttribute("disabled");
      viewBtn.href = href || DEFAULT_FINAL_HTML;
    }
    stopAllTimers();
  }

  function handleError(msg) {
    setStatus(msg || "‚ùå Analysis failed.");
    stopAllTimers();
  }

  function isTimedOut() {
    return (Date.now() - startedAt) > TIMEOUT_MS;
  }

  async function pollStatus() {
    if (finished) return;

    if (isTimedOut()) {
      handleError("‚è∞ Timed out waiting for analysis.");
      return;
    }

    try {
      const bustUrl = STATUS_URL + `?_cb=${Date.now()}`;
      const r = await fetch(bustUrl, { cache: "no-store" });

      if (!r.ok) {
        // before first status file exists, just keep "Initializing‚Ä¶"
        // after first status, keep whatever last message we had
        pollTimerId = setTimeout(pollStatus, 5000);
        return;
      }

      const data = await r.json();
      firstStatusSeen = true;

      const phase = (data.phase || "").toLowerCase();
      const msg   = data.status || "";

      // Ignore obviously stale status (older than when we clicked RUN)
      if (typeof data.timestamp === "number") {
        const tsMs = data.timestamp * 1000;
        if (tsMs < (startedAt - 5000)) {
          // stale status from a previous run, ignore and keep polling
          pollTimerId = setTimeout(pollStatus, 5000);
          return;
        }
      }

      if (/error|fail/.test(phase)) {
        handleError(msg || "‚ùå Analysis error.");
        return;
      }

      if (/publish/.test(phase)) {
        setStatus(msg || "üöÄ Publishing results‚Ä¶");
        pollTimerId = setTimeout(pollStatus, 4000);
        return;
      }

      if (/done|complete/.test(phase)) {
        // Build final HTML URL: use data.html if present, else default
        let htmlPath = data.html || `analysis/${rawLabel}/${rawLabel}.analysis.html`;
        // if htmlPath is relative (most likely), prefix GH_PAGES_BASE
        let href = htmlPath;
        if (!/^https?:\/\//i.test(htmlPath)) {
          href = GH_PAGES_BASE + htmlPath.replace(/^\/+/, "");
        }
        showDone(msg || "‚úÖ Analysis complete.", href);
        return;
      }

      // Anything else => running
      setStatus(msg || "‚è≥ Running analysis‚Ä¶");
      pollTimerId = setTimeout(pollStatus, 4000);
    } catch (e) {
      // Network flakiness: keep trying
      pollTimerId = setTimeout(pollStatus, 5000);
    }
  }

  async function startJob() {
    if (!rawLabel || !fromTxt || !toTxt) {
      handleError("‚ùå Missing label/from/to in URL.");
      return;
    }

    startedAt = Date.now();
    setStatus("‚è≥ Initializing‚Ä¶");

    if (viewBtn) {
      viewBtn.setAttribute("disabled", "disabled");
      viewBtn.removeAttribute("href");
    }

    startElapsedTimer();

    try {
      const payload = { label: rawLabel, from: fromTxt, to: toTxt };
      const r = await fetch(WORKER_URL, {
        method: "POST",
        headers: { "Content-Type": "application/json" },
        body: JSON.stringify(payload),
      });

      if (!r.ok) {
        handleError("‚ùå Failed to start analysis (worker error).");
        return;
      }

      // We don't *need* the body, but parse once for validation
      // If the worker returns `{ok:true, triggered:{...}}` we just trust it.
      await r.json().catch(() => {});

      // Worker accepted the job, now we poll status
      setStatus("‚è≥ Running analysis‚Ä¶");
      pollStatus();
    } catch (e) {
      handleError("‚ùå Failed to reach worker.");
    }
  }

  window.addEventListener("load", startJob);
})();
</script></body>
</html>
