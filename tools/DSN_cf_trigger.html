<!DOCTYPE html>
<html lang="en">
<head>
  <meta charset="utf-8">
  <title>DSN Analysis</title>
  <meta name="viewport" content="width=device-width, initial-scale=1" />
  <style>
    body {
      font-family: system-ui, -apple-system, BlinkMacSystemFont, sans-serif;
      background: #05060a;
      color: #eee;
      margin: 0;
      padding: 1rem 1.5rem;
    }
    h1 {
      font-size: 1.3rem;
      margin: 0 0 0.4rem 0;
    }
    .site {
      font-size: 0.95rem;
      margin-bottom: 0.75rem;
      color: #aaa;
    }
    .status {
      margin: 0.6rem 0 0.2rem 0;
      min-height: 1.4rem;
    }
    .row {
      margin-top: 0.4rem;
      display: flex;
      align-items: center;
      gap: 0.75rem;
      font-size: 0.9rem;
    }
    .btn {
      display: inline-block;
      padding: 0.35rem 0.8rem;
      font-size: 0.9rem;
      border-radius: 999px;
      border: 1px solid #3b82f6;
      background: #0b1120;
      color: #e5e7eb;
      text-decoration: none;
      cursor: pointer;
      transition: background 0.15s ease, color 0.15s ease, border-color 0.15s ease;
    }
    .btn[disabled] {
      opacity: 0.4;
      cursor: default;
    }
    .btn:not([disabled]):hover {
      background: #1d4ed8;
      color: white;
    }
    .timer {
      font-variant-numeric: tabular-nums;
      font-size: 0.85rem;
      color: #a5b4fc;
    }
    .bar-wrap {
      margin-top: 0.6rem;
      margin-bottom: 0.2rem;
      width: 100%;
      max-width: 360px;
    }
    .bar {
      position: relative;
      width: 100%;
      height: 0.4rem;
      border-radius: 999px;
      background: rgba(148, 163, 184, 0.25);
      overflow: hidden;
    }
    .bar-fill {
      width: 0%;
      height: 100%;
      border-radius: inherit;
      background: linear-gradient(90deg, #60a5fa, #22c55e);
      transition: width 0.3s linear;  /* smooth fill */
    }
    .err {
      color: #fecaca;
    }
    .ok {
      color: #bbf7d0;
    }
  </style>
</head>
<body>
  <h1>üî¨ DSN Analysis V.38</h1>
  <div id="site" class="site"></div>

  <div class="status" id="status">‚è≥ Initializing‚Ä¶</div>

  <div id="barRow" class="bar-wrap">
    <div class="bar"><div class="bar-fill"></div></div>
  </div>

  <div id="timerRow" class="row">
    <div class="timer">
      ‚è± <span id="elapsed">0:00</span> ¬∑ Timeout in <span id="remaining">7:00</span>
    </div>
  </div>

  <div class="row">
    <a id="viewBtn" class="btn" href="#" target="_blank" rel="noopener" disabled>üìÑ View Analysis Result</a>
    <a id="exitBtn" class="btn" href="#" onclick="closeTab()">üîô Exit</a>
  </div>

  <script>
  // Make this tab script-owned so window.close() will work
  if (!window.name) {
    window.name = "dsn_cf_trigger";
    window.open(window.location.href, "_self");
  }
  function closeTab() {
    window.close();
  }
  </script>
<script>
(function () {
  // ---- DOM refs ----
  const statusEl = document.getElementById("status");
  const timerEl  = document.getElementById("timer");
  const viewBtn  = document.getElementById("viewBtn");

  // ---- Query params ----
  const params   = new URLSearchParams(window.location.search);
  const rawLabel = (params.get("label") || "").trim();
  const fromTxt  = (params.get("from")  || "").trim();
  const toTxt    = (params.get("to")    || "").trim();
  // Epoch seconds when this run was triggered (for stale-status detection)
  const startedAt = Math.floor(Date.now() / 1000);
  // ---- Constants ----
  const WORKER_URL    = "https://dsn-analysis.dsn-analysis.workers.dev/";
  const GH_RAW_BASE   = "https://raw.githubusercontent.com/soazcomms/soazcomms.github.io/main/";
  const GH_PAGES_BASE = "https://soazcomms.github.io/";

  // status file: status/status-<label>.json
  const STATUS_URL =`${GH_RAW_BASE}status/status-${encodeURIComponent(rawLabel)}.json`;
  // default final HTML if status.html is missing
  const DEFAULT_FINAL_HTML =
    `${GH_PAGES_BASE}analysis/${encodeURIComponent(rawLabel)}/${encodeURIComponent(rawLabel)}.analysis.html`;

  // ---- timers & state ----
  let statusTimerId = null;
  let timeoutTimerId = null;
  let barTimerId    = null;
  let startEpoch    = 0;   // seconds since epoch when we started THIS run
  let startedAt      = Date.now();
  let pollTimerId    = null;
  let elapsedTimerId = null;
  let firstStatusSeen = false;
  let finished       = false;
  const TIMEOUT_MS   = 7 * 60 * 1000; // 7 minutes

  function startAllTimers() {
    startEpoch = Math.floor(Date.now() / 1000); // mark ‚Äústart‚Äù for this run
    if (!timerSpan) return;
    timerSpan.textContent = "0:00";
    const start = Date.now();
    statusTimerId = setInterval(() => {
      const diff = Math.floor((Date.now() - start) / 1000);
      const m    = Math.floor(diff / 60);
      const s    = diff % 60;
      timerSpan.textContent = `${m}:${s.toString().padStart(2, "0")}`;
    }, 1000);
  }

  function stopAllTimers() {
    if (statusTimerId) { clearInterval(statusTimerId); statusTimerId = null; }
    if (timeoutTimerId){ clearTimeout(timeoutTimerId);  timeoutTimerId = null; }
    if (barTimerId)    { clearInterval(barTimerId);     barTimerId    = null; }
  }

  function startElapsedTimer() {
    if (!timerEl) return;
    elapsedTimerId = setInterval(() => {
      const delta = Date.now() - startedAt;
      const secs  = Math.floor(delta / 1000);
      const mm    = String(Math.floor(secs / 60)).padStart(1, "0");
      const ss    = String(secs % 60).padStart(2, "0");
      const remain = Math.max(0, TIMEOUT_MS - delta);
      const rsecs   = Math.floor(remain / 1000);
      const rmm     = String(Math.floor(rsecs / 60)).padStart(1, "0");
      const rss     = String(rsecs % 60).padStart(2, "0");
      timerEl.textContent = `‚è± ${mm}:${ss} ¬∑ Timeout in ${rmm}:${rss}`;
    }, 1000);
  }

  function setStatus(msg) {
    if (statusEl) statusEl.textContent = msg;
  }

  function showDone(msg, href) {
    statusEl.textContent = msg || "‚úÖ Analysis complete.";
    if (viewBtn && href) {
      viewBtn.removeAttribute("disabled");
      viewBtn.href = href;
    }
    // We *do* stop the timers, but we DO NOT hide the timer row,
    // so the elapsed time stays on screen.
    stopAllTimers();
  }
 
  function handleError(msg) {
    setStatus(msg || "‚ùå Analysis failed.");
    stopAllTimers();
  }

  function isTimedOut() {
    return (Date.now() - startedAt) > TIMEOUT_MS;
  }

  async function fetchStatusJSON() {
    try {
      const url = `${STATUS_URL}?_cb=${Date.now()}`;
      const r   = await fetch(url, { cache: "no-store" });
      if (!r.ok) {
        console.log("status_fetch_not_ok", r.status);
        return null;
      }
      return await r.json();
    } catch (e) {
      console.log("status_fetch_error", e);
      return null;
    }
  }

  async function pollStatus() {
    if (!startEpoch) {
      // We haven‚Äôt started this run yet ‚Äì nothing to do.
      return;
    }

    const data = await fetchStatusJSON();
    if (!data) {
      // Couldn‚Äôt read JSON (or 404) ‚Äì keep waiting.
      statusEl.textContent = "‚è≥ Initializing‚Ä¶";
      return;
    }

    const phase  = (data.phase  || "").toLowerCase();
    const status = (data.status || "").trim();
    const ts     = typeof data.timestamp === "number" ? data.timestamp : 0;

    // --------- STALENESS GUARD (CRITICAL) ----------
    // If the status file timestamp is older than when THIS tab started
    // (with a small 5s slack), treat it as stale from a previous run.
    if (ts && ts < (startEpoch - 5)) {
      // This is an old ‚Äúdone‚Äù (or whatever) from an earlier run.
      statusEl.textContent = "‚è≥ Waiting for fresh status‚Ä¶";
      return;
    }
    // ------------------------------------------------

    // No phase yet ‚Üí still coming up
    if (!phase) {
      statusEl.textContent = "‚è≥ Initializing‚Ä¶";
      return;
    }

    if (phase.includes("publish")) {
      statusEl.textContent = "üöÄ Publishing results‚Ä¶";
      return;
    }

    if (phase.includes("run")) {
      statusEl.textContent = "‚è≥ Running analysis‚Ä¶";
      return;
    }

    if (phase.includes("done") || phase.includes("complete")) {
      const href = data.html
        ? `${GH_PAGES_BASE}${data.html}`
        : FINAL_HTML;

      // This will:
      //  - set the ‚úÖ message
      //  - enable and wire up the View button
      showDone(status || `‚úÖ Analysis complete for ${rawLabel}`, href);

      // Freeze the timers at the final value, but keep 0:SS visible.
      stopAllTimers();
      return;
    }

    // Fallback ‚Äì some other phase text
    statusEl.textContent = status || "‚è≥ Working‚Ä¶";
  }
 
  async function startJob(label, fromTxt, toTxt) {
    statusEl.textContent = "‚è≥ Initializing‚Ä¶";
    viewBtn.setAttribute("disabled", "true");
    viewBtn.removeAttribute("href");

    startAllTimers();

    try {
      const resp = await fetch(WORKER_URL, {
        method: "POST",
        headers: { "Content-Type": "application/json" },
        body: JSON.stringify({ label, from: fromTxt, to: toTxt }),
      });
  
      if (!resp.ok) {
        statusEl.textContent = `‚ùå Worker error (${resp.status})`;
        stopAllTimers();
      return;
      }

      const js = await resp.json();
      if (!js.ok) {
        statusEl.textContent = "‚ùå Worker refused job.";
        stopAllTimers();
        return;
      }
  
      // Worker accepted ‚Äì now we poll GitHub status JSON
      statusEl.textContent = "‚è≥ Running analysis‚Ä¶";
  
      // Start the polling loop
      pollStatus(); // first hit immediately
      statusTimerId = setInterval(pollStatus, 5000);
  
    } catch (e) {
      console.log("worker_fetch_exception", e);
      statusEl.textContent = "‚ùå Failed to reach worker.";
      stopAllTimers();
    }
  }
  window.addEventListener("load", startJob);
})();
</script></body>
</html>
