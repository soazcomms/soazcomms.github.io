<!doctype html>
<html lang="en">
<meta charset="utf-8" />
<title>DSN CSV Export</title>
<meta name="viewport" content="width=device-width,initial-scale=1" />
<style>
  body{font-family:system-ui,-apple-system,Segoe UI,Roboto,Arial,sans-serif;margin:20px;line-height:1.45}
  .wrap{max-width:780px}
  h1{margin:0 0 .5rem 0}
  .muted{color:#666}
  .row{margin:1rem 0}
  .btn{display:inline-block;padding:.6rem 1rem;border:1px solid #ddd;border-radius:8px;text-decoration:none;cursor:pointer}
  .btn.disabled{opacity:.5;pointer-events:none}
  .ok{color:#0a6}
  .err{color:#b00}
  /* keep your existing progress bar look/size/colors */
  .bar{height:14px;background:#222;border-radius:7px;overflow:hidden;outline:2px solid #900}
  .bar>span{display:block;height:100%;width:0%;
            background:#ff1744;box-shadow:0 0 6px #ff1744,0 0 12px #ff1744;transition:width .45s ease}
  .done .bar>span{background:#18c37e;box-shadow:0 0 6px #18c37e,0 0 12px #18c37e}
  .hint{font-size:.9rem;color:#666}
</style>

<div class="wrap" id="wrap">
  <h1>DSN CSV Export</h1>
  <div class="muted" id="desc">Preparing‚Ä¶</div>

  <div class="row"><div class="bar"><span id="bar"></span></div></div>

  <div class="row">
    <a id="download" class="btn disabled" href="#">‚¨á Download CSV</a>
    <a id="viewlog" class="btn disabled" target="_blank" rel="noopener" href="#">ü™µ View log</a>
    <a id="retry" class="btn" href="#" style="display:none;">‚Üª Retry</a>
  </div>

  <div class="row muted" id="status">‚öôÔ∏è Working‚Ä¶</div>
  <div class="row hint" id="hint" style="display:none;"></div>
</div>

<script>
(() => {
  // --- constants ---
  const GH_PAGES_BASE = "https://soazcomms.github.io";
  const GH_RAW_BASE   = "https://raw.githubusercontent.com/soazcomms/soazcomms.github.io/main";
  const WEBHOOK_URL   = "https://sound-kangaroo-unlikely.ngrok-free.app/DSN_csv";
  const CLEANUP_URL   = "https://sound-kangaroo-unlikely.ngrok-free.app/DSN_cleanup";

  // --- qs / dom ---
  const qs      = new URLSearchParams(location.search);
  const label   = (qs.get("label")||"").trim();
  const fromQ   = (qs.get("from") || "").trim();
  const toQ     = (qs.get("to")   || "").trim();

  const wrapEl  = document.getElementById("wrap");
  const statusEl= document.getElementById("status");
  const barEl   = document.getElementById("bar");
  const dlEl    = document.getElementById("download");
  const logEl   = document.getElementById("viewlog");
  const retryEl = document.getElementById("retry");
  const descEl  = document.getElementById("desc");
  const hintEl  = document.getElementById("hint");

  const toYMD = s => String(s).slice(0,10).replaceAll("/","-");
  const yFrom = toYMD(fromQ), yTo = toYMD(toQ);
  descEl.textContent = `Label: ${label} ¬∑ Range: ${yFrom} ‚Üí ${yTo}`;

  const yFromC = yFrom.replaceAll("-","");
  const yToC   = yTo.replaceAll("-","");
  const safeLabel = (label||"").replace(/[^\w.\-]+/g, "_");

  // progress bar (unchanged visuals)
  let pct=8, ticks=0;
  barEl.style.width = pct + "%";
  const tTick=setInterval(()=>{ pct=Math.min(95,pct+1+Math.min(6,Math.floor(ticks/5))); barEl.style.width=pct+"%"; ticks++; }, 900);

  // fire server job (idempotent)
  fetch(WEBHOOK_URL, {
    method: "POST",
    headers: {"content-type":"application/json"},
    body: JSON.stringify({ label, from: yFrom, to: yTo })
  }).then(()=>{ statusEl.textContent = "Triggered‚Ä¶ generating CSV"; })
    .catch(()=>{ statusEl.textContent = "Triggered (no response)"; });

  // status JSON (prefer RAW? no ‚Äî Pages is fine since it‚Äôs tiny)
  const statusRel = `status/status-${safeLabel}.json`;
  const statusPg  = `${GH_PAGES_BASE}/${statusRel}`;

  // util: small existence check (short range to avoid full download)
  async function headSmall(u) {
    try {
      const r = await fetch(u + (u.includes("?") ? "&" : "?") + "bust=" + Date.now(), {
        method: "GET",
        headers: {"Range":"bytes=0-128"},
        cache: "no-store",
        redirect: "follow"
      });
      if (!r.ok) return { ok:false, status:r.status };
      return { ok:true, status:r.status };
    } catch { return { ok:false, status:0 }; }
  }

  // util: fetch JSON status
  async function getStatus() {
    try {
      const r = await fetch(statusPg + "?bust=" + Date.now(), { cache:"no-store" });
      if (!r.ok) return null;
      return await r.json();
    } catch { return null; }
  }

  // build strict candidates
  const csvRel = `DSNdata/${safeLabel}_${yFromC}_${yToC}.csv`;
  const CSV_CANDIDATES = [
    `${GH_PAGES_BASE}/${csvRel}`,     // Pages
    `${GH_RAW_BASE}/${csvRel}`,       // Raw
  ];

  // log candidates (status first, then guesses)
  function logCandidatesFromStatus(data) {
    const c = [];
    if (data && data.log) {
      c.push(/^https?:\/\//i.test(data.log) ? data.log
            : `${GH_PAGES_BASE}/${String(data.log).replace(/^\/+/, "")}`);
    }
    if (data && data.log_raw) c.push(data.log_raw);
    // common guesses
    const guess1 = `logs/csv-${safeLabel}-${yFromC}-${yToC}.log`;
    const guess2 = `DSNdata/RUN_LOG/csv-${safeLabel}-${yFromC}-${yToC}.log`;
    c.push(`${GH_PAGES_BASE}/${guess1}`, `${GH_RAW_BASE}/${guess1}`,
           `${GH_PAGES_BASE}/${guess2}`, `${GH_RAW_BASE}/${guess2}`);
    // de-dup + encode
    return Array.from(new Set(c.filter(Boolean).map(u => encodeURI(u))));
  }

  let armedDownloadUrl = "";  // confirmed working CSV URL
  let armedLogUrl = "";       // confirmed working log URL

  // arm download on the first live URL (no whole-file fetch yet)
  async function armDownload() {
    for (const u of CSV_CANDIDATES) {
      const { ok } = await headSmall(u);
      if (ok) {
        armedDownloadUrl = u;
        dlEl.href = "#";
        dlEl.onclick = async (e)=>{
          e.preventDefault();
          // Now fetch fully to Blob & download
          const r = await fetch(armedDownloadUrl + (armedDownloadUrl.includes("?")?"&":"?") + "bust=" + Date.now(), { cache:"no-store" });
          if (!r.ok) { statusEl.textContent = `‚ö†Ô∏è Download failed: HTTP ${r.status}`; return; }
          const blob = await r.blob();
          const url = URL.createObjectURL(blob);
          const a = document.createElement("a");
          a.href = url; a.download = `${safeLabel}_${yFrom}_${yTo}.csv`;
          document.body.appendChild(a); a.click();
          setTimeout(()=>{ URL.revokeObjectURL(url); a.remove(); }, 250);

          // best-effort cleanup
          statusEl.textContent = "üßπ Cleaning up‚Ä¶";
          fetch(CLEANUP_URL, {
            method:"POST",
            headers:{"content-type":"application/json"},
            body: JSON.stringify({ label, from: yFrom, to: yTo })
          }).catch(()=>{});
          wrapEl.classList.add("done");
          barEl.style.width="100%";
          statusEl.innerHTML = '<span class="ok">‚úÖ CSV downloaded.</span>';
        };
        setDisabled(dlEl,false);
        return true;
      }
    }
    return false;
  }

  // arm log open on the first live URL
  async function armLog(cands) {
    for (const u of cands) {
      const { ok } = await headSmall(u);
      if (ok) {
        armedLogUrl = u;
        logEl.href = u + (u.includes("?")?"&":"?") + "bust=" + Date.now();
        setDisabled(logEl,false);
        return true;
      }
    }
    return false;
  }

  // poll only status JSON
  const tPoll = setInterval(async ()=>{
    const data = await getStatus();
    if (!data) { statusEl.textContent = "‚öôÔ∏è Working‚Ä¶"; return; }

    // keep bar alive when timestamp ticks
    if (data.timestamp) { pct = Math.min(97, pct+2); barEl.style.width = pct + "%"; }

    const phase = String(data.phase||"").toLowerCase();

    if (phase === "done") {
      clearInterval(tPoll); clearInterval(tTick);
      // arm buttons using strict candidates
      const armedOk = await armDownload();
      await armLog(logCandidatesFromStatus(data));

      barEl.style.width = "100%";
      wrapEl.classList.add("done");
      statusEl.innerHTML = armedOk
        ? '<span class="ok">‚úÖ CSV ready.</span>'
        : '<span class="err">‚ùå File not found where expected.</span>';

      hintEl.style.display = "block";
      hintEl.textContent = "Tip: If your browser blocks the first attempt, click Download again.";
      return;
    }

    if (phase === "error") {
      clearInterval(tPoll); clearInterval(tTick);
      barEl.style.width = "100%";
      statusEl.innerHTML = `<span class="err">‚ùå Failed.</span>`;
      retryEl.style.display="inline-block";
      retryEl.onclick=(e)=>{ e.preventDefault(); location.reload(); };
      return;
    }

    // neutral text only
    statusEl.textContent = "‚öôÔ∏è Working‚Ä¶";
  }, 900);

  // helpers
  function setDisabled(a, dis=true) {
    if (dis) { a.classList.add("disabled"); a.setAttribute("aria-disabled","true"); }
    else { a.classList.remove("disabled"); a.removeAttribute("aria-disabled"); }
  }
})();
</script>
</html>

<!-- STAMP: DSN_csv_trigger 20251030130624 -->
<div id="stamp" style="position:fixed;right:8px;bottom:8px;font:12px/1.2 monospace;color:#999;">STAMP 20251030130624</div>
