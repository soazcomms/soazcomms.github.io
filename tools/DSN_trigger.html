<!doctype html>
<html lang="en">
<head>
  <meta charset="utf-8"/>
  <title>üî¨ DSN Analysis</title>
  <meta name="viewport" content="width=device-width, initial-scale=1"/>
  <meta http-equiv="Cache-Control" content="no-store, max-age=0" />
  <meta http-equiv="Pragma" content="no-cache" />
  <meta http-equiv="Expires" content="0" />
  <style>
    :root { --primary:#007bff; --accent:#87CEFA; --ok:#2e7d32; --warn:#c62828; --barbg:#edf2f7; }
    body{font:16px/1.35 -apple-system,BlinkMacSystemFont,Segoe UI,Roboto,Helvetica,Arial,sans-serif;margin:24px;max-width:900px}
    h1{margin:0 0 8px 0}
    .muted{opacity:.75}
    .row{margin:10px 0}
    .btn{display:inline-block;padding:8px 12px;border-radius:8px;border:1px solid #ccc;text-decoration:none}
    .btn[disabled]{opacity:.4;pointer-events:none}
    #barwrap{height:10px;background:var(--barbg);border-radius:999px;overflow:hidden;margin:12px 0 4px 0;box-shadow:inset 0 0 0 1px #e2e8f0}
    #bar{height:100%;width:0%;background:linear-gradient(90deg,#69c,#38bdf8 40%,#22c55e 75%,#16a34a 100%);transition:width .5s ease}
    #bar.timeout{background:linear-gradient(90deg,#f59e0b,#ef4444)}
    #status{margin:8px 0;min-height:2.2em}
    #controls a{margin-right:10px}
    details{border:1px solid #e5e7eb;border-radius:8px;padding:.5rem 1rem;background:#fafafa}
    details pre{white-space:pre-wrap;word-break:break-word;background:#fff;border:1px solid #eee;border-radius:6px;padding:.75rem;max-height:260px;overflow:auto}
    code{font-family:ui-monospace,SFMono-Regular,Menlo,Monaco,Consolas,Liberation Mono,monospace}
    .done{border:1px solid #dcfce7;background:#f0fdf4;border-radius:10px;padding:12px;margin-top:16px}
    .badge{display:inline-block;padding:.15rem .45rem;border-radius:6px;border:1px solid #e5e7eb;background:#f8fafc;font-size:.9rem}
  </style>
</head>
<body>
  <h1 id="title">üî¨ DSN Analysis</h1>
  <div id="header" class="muted">‚è≥ Initializing‚Ä¶ --V5-- <span id="jsBadge" class="badge">JS: starting</span></div>
  <div id="barwrap"><div id="bar"></div></div>
  <div class="row" id="status">Preparing‚Ä¶</div>
  <div class="row">
    <span id="elapsed">0:00</span>
    <span class="muted"> ¬∑ Timeout in <span id="timeoutLeft">7:00</span></span>
  </div>
  <div id="controls" class="row">
    <a id="viewBtn" class="btn" href="#" target="_blank" rel="noopener" disabled>üìÑ View Analysis Result</a>
    <a id="exitBtn" class="btn" href="about:blank">üîô Exit</a>
  </div>
<script>
(function(){
  /* ========== CONFIG / PARAMS ========== */

  // Parse URL params
  const qs = new URLSearchParams(location.search || "");
  const rawLabel = (qs.get("label") || "").trim();
  const fromTxt  = (qs.get("from")  || "").trim();   // "YYYY-MM-DD HH:MM:SS" Grafana
  const toTxt    = (qs.get("to")    || "").trim();
  const WEBHOOK_ORIG = (qs.get("webhook") || qs.get("webhook_id") || "").trim()
                        ? (qs.get("webhook") || `https://${qs.get("webhook_id").trim()}.ngrok-free.app`).replace(/\/+$/,"")
                        : "";
  const WEBHOOK_URL  = WEBHOOK_ORIG ? (WEBHOOK_ORIG + "/DSN_trigger") : "";
  const GH_PAGES_BASE = "https://soazcomms.github.io/";
  const STATUS_DIR    = "status";

  // DOM hooks (assumes your page already has these elements)
  const titleEl   = document.getElementById("title")   || {textContent: ""};
  const headerEl  = document.getElementById("header")  || {textContent: ""};
  const statusEl  = document.getElementById("status")  || {textContent: ""};
  const bar       = document.getElementById("bar")     || {style:{}, classList:{add(){}}};
  const elapsedEl = document.getElementById("elapsed") || {textContent: ""};
  const leftEl    = document.getElementById("timeoutLeft") || {textContent: ""};
  const viewBtn   = document.getElementById("viewBtn") || {removeAttribute(){}, setAttribute(){}, href:"#"};
  const jsBadge   = document.getElementById("jsBadge") || {textContent:""};

  function setJS(state){ try{ jsBadge.textContent = "JS: " + state; }catch(_){ } }

  // Small helpers
  function onlyDate(s){ if(!s) return s; if(s.includes(" ")) return s.split(" ")[0]; return s.split("T")[0]; }
  function safeShort(lbl){ return (lbl||"").split("_")[0].replace(/[^\w.\-]/g,"_"); }

  // Server-side logger (image beacon ‚Üí always hits Flask /log; no CORS reads needed)
  function srvlog(msg, fields){
    try {
      const p = new URLSearchParams();
      p.set("msg", msg);
      p.set("label", rawLabel || "");
      if (fields && typeof fields === "object") {
        for (const k in fields) {
          if (!Object.prototype.hasOwnProperty.call(fields,k)) continue;
          let v = fields[k];
          if (v == null) continue;
          v = String(v);
          p.set(k, v.length > 400 ? v.slice(0,400) + "‚Ä¶(trunc)" : v);
        }
      }
      p.set("t", Date.now()); // cache-bust
      if (WEBHOOK_ORIG) {
        const i = new Image();
        i.src = WEBHOOK_ORIG + "/log?" + p.toString();
      }
    } catch(_) {}
  }

  /* ========== BOOT ========== */

  setJS("starting");
  document.title = `üî¨ DSN Analysis`;
  titleEl.textContent = `üî¨ DSN Analysis`;
  headerEl.textContent = `‚è≥ Initializing‚Ä¶`;

  // Validate inputs
  if (!rawLabel || !fromTxt || !toTxt || !WEBHOOK_URL) {
    statusEl.innerHTML = "‚ùå Missing label/from/to/webhook.";
    setJS("params-missing");
    srvlog("fatal_params_missing", { label: rawLabel, from: fromTxt, to: toTxt, webhook: WEBHOOK_URL ? "set" : "missing" });
    return;
  }

  // Populate header now
  const label8 = safeShort(rawLabel);
  document.title = `üî¨ DSN Analysis `;
  titleEl.textContent = `üî¨ DSN Analysis V.07`;
  headerEl.textContent = `Site: ${rawLabel} Range: ${onlyDate(fromTxt)} ‚Üí ${onlyDate(toTxt)}`;
  setJS("alive");
  srvlog("boot", { href: location.href, in_iframe: (window.top === window ? "no" : "yes"), v: "V5-srv" });

  /* ========== TIMERS / PROGRESS ========== */
  const startTs = Date.now();
  const HARD_TIMEOUT_MS = 7 * 60 * 1000;
  let timersActive = true, timedOut = false;

  function stopAllTimers(){
    if (!timersActive) return;
    timersActive = false;
    clearInterval(tIv);
    clearInterval(pIv);
  }
  function mmss(ms){ const s=Math.max(0,Math.floor(ms/1000)); return `${Math.floor(s/60)}:${String(s%60).padStart(2,"0")}`; }
  function tickTime(){
    const t = Date.now()-startTs;
    elapsedEl.textContent = mmss(t);
    const left = Math.max(0, HARD_TIMEOUT_MS - t);
    leftEl.textContent = mmss(left);
    try { bar.style.width = Math.min(99, Math.floor((t/HARD_TIMEOUT_MS)*100)) + "%"; } catch(_){}
    if (left === 0 && !timedOut){ timedOut = true; try{ bar.classList.add("timeout"); }catch(_){} }
  }
  const tIv = setInterval(tickTime, 1000); tickTime();

  setTimeout(function(){
    if (!timersActive) return;
    stopAllTimers();
    try { bar.style.width = "100%"; }catch(_){}
    statusEl.innerHTML = "‚ùå Timed out waiting for analysis.";
    srvlog("timeout", { elapsed_ms: (Date.now()-startTs) });
  }, HARD_TIMEOUT_MS);

  /* ========== HEALTH CHECKS (best-effort) ========== */
  async function healthChecks(){
    const targets = [
      {name:"/health", url: WEBHOOK_ORIG + "/health"},
      {name:"/DSN_trigger?ping=1", url: WEBHOOK_URL + "?ping=1"},
      {name:"/log?msg=client_start&label="+encodeURIComponent(rawLabel), url: WEBHOOK_ORIG + "/log?msg=client_start&label="+encodeURIComponent(rawLabel)}
    ];
    for (const t of targets){
      try{
        srvlog("health_req", { url: t.url });
        const r = await fetch(t.url, {method:"GET", cache:"no-store", mode:"cors", credentials:"omit"});
        srvlog("health_resp", { url: t.url, status: r.status });
      }catch(e){
        srvlog("health_err", { url: t.url, err: (e && e.message) ? e.message : String(e) });
      }
    }
  }

  /* ========== KICK THE JOB (POST /DSN_trigger) ========== */
  let posted = false;
  async function startJobOnce(){
    if (posted) return; posted = true;
    const payload = { label: rawLabel, from: fromTxt, to: toTxt }; // plain timestamps
    srvlog("post_build", { url: WEBHOOK_URL, label: rawLabel, from: payload.from, to: payload.to });
    try{
      srvlog("post_send", { url: WEBHOOK_URL });
      const resp = await fetch(WEBHOOK_URL, {
        method: "POST",
        mode: "cors",
        credentials: "omit",
        cache: "no-store",
        headers: {"Content-Type": "application/json"},
        body: JSON.stringify(payload)
      });
      srvlog("post_rc", { status: resp.status });
      if (!resp.ok){
        statusEl.innerHTML = `‚ùå Job failed to start (HTTP ${resp.status}).`;
        try { bar.style.width = "100%"; }catch(_){}
        stopAllTimers();
        return;
      }
      statusEl.textContent = "‚è≥ Running analysis‚Ä¶";
    }catch(e){
      srvlog("post_err", { err: (e && e.message) ? e.message : String(e) });
      statusEl.textContent = "‚ùå Could not reach webhook.";
      try { bar.style.width = "100%"; }catch(_){}
      stopAllTimers();
    }
  }

  /* ========== STATUS POLLING (GitHub Pages) ========== */
  const statusUrls = [
    `${GH_PAGES_BASE}${STATUS_DIR}/status-${encodeURIComponent(rawLabel)}.json`,
    `${GH_PAGES_BASE}${STATUS_DIR}/status-${encodeURIComponent(label8)}.json`,
  ];
  function bust(u){ return u + (u.includes("?")?"&":"?") + "bust=" + Date.now(); }

  async function fetchNewestWithHtml(){
    const found = [];
    for (const u of statusUrls){
      try{
        srvlog("poll_req", { url: u });
        const r = await fetch(bust(u), {cache:"no-store"});
        srvlog("poll_rc", { url: u, status: r.status });
        if (!r.ok) continue;
        const j = await r.json();
        srvlog("poll_json", { url: u, phase: j && j.phase, has_html: (j && j.html) ? "yes":"no" });
        const ts = Number(j.timestamp)||0;
        if (j && j.html && String(j.html).trim()){
          found.push({data:j, ts});
        }
      }catch(e){
        srvlog("poll_err", { url: u, err: (e && e.message) ? e.message : String(e) });
      }
    }
    if (!found.length) return null;
    found.sort((a,b)=> b.ts - a.ts);
    return found[0].data;
  }

  function showDone(statusText, href){
    stopAllTimers();
    try { bar.style.width = "100%"; }catch(_){}
    try { viewBtn.removeAttribute("disabled"); viewBtn.href = href; }catch(_){}
    statusEl.innerHTML = statusText || "‚úÖ Analysis complete.";
    headerEl.textContent = headerEl.textContent + " ‚Äî DONE";
    srvlog("done", { html: href });
    try { window.stop && window.stop(); } catch(_){}
  }

  async function pollStatus(){
    const data = await fetchNewestWithHtml();
    if (!data){ statusEl.innerHTML = "‚è≥ Generating plots‚Ä¶"; return; }
    if (data.phase === "error"){
      stopAllTimers();
      statusEl.innerHTML = data.status || "‚ùå Analysis failed.";
      try { bar.style.width = "100%"; }catch(_){}
      return;
    }
    const htmlRel = String(data.html||"").trim();
    if (!htmlRel){ statusEl.innerHTML = "‚è≥ Generating plots‚Ä¶"; return; }
    const href = GH_PAGES_BASE + htmlRel.replace(/^\/+/, "");
    showDone(data.status, href);
  }
  const pIv = setInterval(pollStatus, 1500);

  /* ========== START ========== */
  healthChecks();
  startJobOnce();

  // Optional: page becomes idle if we ever bail early (uncomment if you add early returns)
  // srvlog("page_idle", { reason: "early-exit" });

})();
</script>
</body>
</html>
