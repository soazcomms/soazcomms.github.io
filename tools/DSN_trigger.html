<!doctype html>
<html lang="en">
<head>
  <meta charset="utf-8"/>
  <title>üî¨ DSN Analysis</title>
  <meta name="viewport" content="width=device-width, initial-scale=1"/>
  <meta http-equiv="Cache-Control" content="no-store, max-age=0" />
  <meta http-equiv="Pragma" content="no-cache" />
  <meta http-equiv="Expires" content="0" />
  <style>
    :root { --primary:#007bff; --accent:#87CEFA; --ok:#2e7d32; --warn:#c62828; --barbg:#edf2f7; }
    body{font:16px/1.35 -apple-system,BlinkMacSystemFont,Segoe UI,Roboto,Helvetica,Arial,sans-serif;margin:24px;max-width:900px}
    h1{margin:0 0 8px 0}
    .muted{opacity:.75}
    .row{margin:10px 0}
    .btn{display:inline-block;padding:8px 12px;border-radius:8px;border:1px solid #ccc;text-decoration:none}
    .btn[disabled]{opacity:.4;pointer-events:none}
    #barwrap{
      height:10px;
      width:50%;
      background:var(--barbg);
      border-radius:999px;
      overflow:hidden;
      margin:12px 0 4px 0;
      box-shadow:inset 0 0 0 1px #e2e8f0;
      display:block;
      margin-left:0;
      margin-right:auto;
    }
    #bar{
      height:100%;
      width:0%;
      background:linear-gradient(90deg,#69c,#38bdf8 40%,#22c55e 75%,#16a34a 100%);
      transition:width .5s ease
    }
    #bar.timeout{
      background:linear-gradient(90deg,#f59e0b,#ef4444)
    }
    status{margin:8px 0;min-height:2.2em}
    controls a{margin-right:10px}
    .done{border:1px solid #dcfce7;background:#f0fdf4;border-radius:10px;padding:12px;margin-top:16px}
    .badge{display:inline-block;padding:.15rem .45rem;border-radius:6px;border:1px solid #e5e7eb;background:#f8fafc;font-size:.9rem}
    details{border:1px solid #e5e7eb;border-radius:8px;padding:.5rem 1rem;background:#fafafa}
    details pre{white-space:pre-wrap;word-break:break-word;background:#fff;border:1px solid #eee;border-radius:6px;padding:.75rem;max-height:260px;overflow:auto}
    code{font-family:ui-monospace,SFMono-Regular,Menlo,Monaco,Consolas,Liberation Mono,monospace}
  </style>
</head>
<body>
  <h1 id="title">üî¨ DSN Analysis V.26</h1>
  <div id="header" class="muted">‚è≥ Initializing‚Ä¶ <span id="jsBadge" class="badge">JS: starting</span></div>
  <div id="barwrap"><div id="bar"></div></div>
  <div class="row" id="timersRow">
    <span id="elapsed">0:00</span>
    <span class="muted"> ¬∑ Timeout in <span id="timeoutLeft">7:00</span></span>
  </div>
  <div class="row" id="status">Preparing‚Ä¶</div>
  <div id="controls" class="row">
    <a id="viewBtn" class="btn" href="#" target="_blank" rel="noopener" disabled>üìÑ View Analysis Result</a>
    <button id="exitBtn" class="btn" type="button" onclick="return closeTab(event)">üîô Exit</button>
  </div>

<script>
let DID_DONE = false;      // global guard
// Loudly surface any runtime error instead of silently stalling
window.addEventListener("error", (e)=>{
  const statusEl = document.getElementById("status") || document.body;
  statusEl.innerHTML = "‚ùå JS error: " + (e && e.message ? e.message : String(e));
});
let pollTimer = null;      // if you use setInterval
let timeoutTimer = null;   // your countdown timer, if any

function stopAllTimers(){
  if (pollTimer){ clearInterval(pollTimer); pollTimer = null; }
  if (timeoutTimer){ clearInterval(timeoutTimer); timeoutTimer = null; }
}
function closeTab(e){
  if (e) e.preventDefault();
  try { window.close(); return false; } catch (_) {}
  if (document.referrer) { location.replace(document.referrer); return false; }
  if (history.length > 1) { history.back(); return false; }
  location.replace('https://soazcomms.grafana.net/');
  return false;
}
(function(){
  /* ========== PARAMS ========== */
  const qs = new URLSearchParams(location.search || "");
  const rawLabel = (qs.get("label") || "").trim();
  const label8 = safeShort(rawLabel).slice(0, 8);
  const fromTxt  = (qs.get("from")  || "").trim();
  const toTxt    = (qs.get("to")    || "").trim();
  const wid   = (qs.get("webhook_id") || "").trim();
  const tsPat    = /^\d{4}-\d{2}-\d{2} \d{2}:\d{2}:\d{2}$/;
  // send a beacon to server log immediately to see params in logs/debug.log
  (new Image()).src =
  `/log?msg=params&label=${encodeURIComponent(label8)}&lab=${encodeURIComponent(rawLabel)}&from=${encodeURIComponent(fromTxt)}&to=${encodeURIComponent(toTxt)}&wid=${encodeURIComponent(wid)}`;

  const userWebhook = (qs.get("webhook") || "").trim().replace(/\/+$/,"");

  // Build base webhook origin
  let WEBHOOK_ORIG = "";
  if (userWebhook) WEBHOOK_ORIG = userWebhook;
  else if (wid) WEBHOOK_ORIG = `https://${wid}.ngrok-free.app`;

  // Build actual trigger endpoint (avoid double-append)
  let WEBHOOK_URL = "";
  if (WEBHOOK_ORIG) {
    WEBHOOK_URL = WEBHOOK_ORIG.endsWith("/DSN_trigger") ? WEBHOOK_ORIG
                  : WEBHOOK_ORIG + "/DSN_trigger";
  }
  if (!WEBHOOK_ORIG || !WEBHOOK_URL) {
    const statusEl = document.getElementById("status") || document.body;
    statusEl.innerHTML = "‚ùå No webhook configured. Add &webhook_id=<ngrok-subdomain> or &webhook=<full URL>.";
    // Show what we actually saw for quick debugging
    const pre = document.createElement("pre");
    pre.textContent = `wid='${wid}' userWebhook='${userWebhook}'\nWEBHOOK_ORIG='${WEBHOOK_ORIG}'\nWEBHOOK_URL='${WEBHOOK_URL}'`;
    (document.getElementById("debug") || document.body).appendChild(pre);
    throw new Error("missing webhook");
  }
  const GH_PAGES_BASE = "https://soazcomms.github.io/";
  const GH_RAW_BASE = "https://raw.githubusercontent.com/soazcomms/soazcomms.github.io/main/";
  const STATUS_URL = `${GH_RAW_BASE}status/status-${encodeURIComponent(label8)}.json`;
  const STATUS_DIR    = "status";
  const statusUrls  = [
    `${GH_RAW_BASE}${STATUS_DIR}/status-${encodeURIComponent(safeShort(rawLabel))}.json`
  ];
  /* ========== DOM ========== */
  const titleEl   = document.getElementById("title");
  const headerEl  = document.getElementById("header");
  const statusEl = document.getElementById("status") || document.body;
  const bar       = document.getElementById("bar");
  const elapsedEl = document.getElementById("elapsed");
  const leftEl    = document.getElementById("timeoutLeft");
  const viewBtn   = document.getElementById("viewBtn");
  const jsBadge   = document.getElementById("jsBadge");
  const timersRow = document.getElementById("timersRow");

  function setJS(x){ if(jsBadge) jsBadge.textContent = "JS: " + x; }
  function onlyDate(s){ if(!s) return s; if(s.includes(" ")) return s.split(" ")[0]; return s.split("T")[0]; }
  function safeShort(lbl){ return (lbl||"").split("_")[0].replace(/[^\w.\-]/g,"_"); }

  // Final HTML targets (never use index.html)
  const FINAL_PGS = `https://soazcomms.github.io/analysis/${encodeURIComponent(label8)}/${encodeURIComponent(label8)}.analysis.html`;
  const FINAL_RAW = `https://raw.githubusercontent.com/soazcomms/soazcomms.github.io/main/analysis/${encodeURIComponent(label8)}/${encodeURIComponent(label8)}.analysis.html`;
  // Server-side logger (image beacon)
  function srvlog(msg, fields){
    try {
      if (!WEBHOOK_ORIG) return;
      const p = new URLSearchParams();
      p.set("msg", msg);
      p.set("label", rawLabel || "");
      if (fields && typeof fields === "object") {
        for (const k in fields) {
          if (!Object.prototype.hasOwnProperty.call(fields,k)) continue;
          const v = String(fields[k] ?? "");
          p.set(k, v.length > 400 ? v.slice(0,400) + "‚Ä¶(trunc)" : v);
        }
      }
      p.set("t", Date.now());
      const i = new Image();
      i.src = WEBHOOK_ORIG + "/log?" + p.toString();
    } catch(_) {}
  }

  /* ========== BOOT UI ========== */
  setJS("starting");
  document.title = "üî¨ DSN Analysis V.26";
  titleEl.textContent = "üî¨ DSN Analysis V.26";
  headerEl.textContent = "‚è≥ Initializing‚Ä¶";

  if (!rawLabel || !tsPat.test(fromTxt) || !tsPat.test(toTxt) || !wid) {
      statusEl.innerHTML = "‚ùå Missing/invalid params. Expect 'YYYY-MM-DD HH:MM:SS'.";
      const pre = document.createElement("pre");
      pre.textContent = `label=${rawLabel}\nfrom=${fromTxt}\nto=${toTxt}\nwebhook_id=${wid}`;
      (document.getElementById("debug") || document.body).appendChild(pre);
      throw new Error("bad params"); // STOP here; do not attempt POST
  }
  headerEl.textContent = `Site: ${rawLabel} ¬∑ Range: ${onlyDate(fromTxt)} ‚Üí ${onlyDate(toTxt)}`;
  setJS("alive");
  srvlog("boot", { href: location.href });

  /* ========== TIMERS ========== */
  const START = Date.now();
  const HARD_TIMEOUT_MS = 7*60*1000;
  let timersActive = true;
  let timedOut = false;
  const mmss = (ms)=>{ const s=Math.max(0,Math.floor(ms/1000)); return `${Math.floor(s/60)}:${String(s%60).padStart(2,"0")}`; };
  function tickTime(){
    const t = Date.now() - START;
    elapsedEl.textContent = mmss(t);
    const left = Math.max(0, HARD_TIMEOUT_MS - t);
    leftEl.textContent = mmss(left);
    bar.style.width = Math.min(99, Math.floor((t/HARD_TIMEOUT_MS)*100)) + "%";
    if (left===0 && !timedOut){ timedOut = true; bar.classList.add("timeout"); }
  }
  const tIv = setInterval(tickTime, 1000); tickTime();
  const pIv = setInterval(pollStatus, 1200);
  function stopAllTimers(){ if (!timersActive) return; timersActive=false; clearInterval(tIv); clearInterval(pIv); }

  setTimeout(()=>{
    if (!timersActive) return;
    statusEl.innerHTML = "‚ùå Timed out waiting for analysis.";
    bar.style.width = "100%";
    srvlog("timeout", { elapsed_ms: (Date.now()-START) });
    stopAllTimers();
  }, HARD_TIMEOUT_MS);

  /* ========== HEALTH ========== */
  (async ()=>{
    const targets = [
      {n:"/health", u: WEBHOOK_ORIG + "/health"},
      {n:"/DSN_trigger?ping=1", u: WEBHOOK_URL + "?ping=1"},
      {n:"/log?msg=client_start&label="+encodeURIComponent(rawLabel), u: WEBHOOK_ORIG + "/log?msg=client_start&label="+encodeURIComponent(rawLabel)}
    ];
    for (const t of targets){
      try{
        srvlog("health_req", { url: t.u });
        const r = await fetch(t.u, {method:"GET", cache:"no-store", mode:"cors", credentials:"omit"});
        srvlog("health_rc", { url: t.u, status: r.status });
      }catch(e){
        srvlog("health_err", { url: t.u, err: (e && e.message) ? e.message : String(e) });
      }
    }
  })();

  /* ========== START JOB (single POST, no preflight header) ========== */
  let posted = false;
  async function startJobOnce(){
    if (posted) return; posted = true;
    const payload = { label: rawLabel, from: fromTxt, to: toTxt };
    const bodyStr = JSON.stringify(payload);
    try{
      srvlog("post_send", { url: WEBHOOK_URL });
      const rt = await fetch(WEBHOOK_URL, {
        method: "POST",
        mode: "cors",
        credentials: "omit",
        cache: "no-store",
        headers: { "Content-Type": "application/json" },
        body: bodyStr
      });
      srvlog("post_rc", { status: rt.status });
      statusEl.textContent = "‚è≥ Running analysis‚Ä¶";
    }catch(e){
      const msg = (e && e.name === "AbortError") ? "timeout" : (e && e.message) ? e.message : String(e);
      statusEl.innerHTML = `‚ùå Could not reach webhook (${msg}).`;
      srvlog("post_err", { err: msg });
      return; // stop; don‚Äôt poll when POST didn‚Äôt happen
    }
  }

  /* ========== STATUS POLLING (Pages) ========== */
  function bust(u){ return u + (u.includes("?")?"&":"?") + "_cb=" + Date.now(); }
  async function headOK(url){
    try{
      const r = await fetch(bust(url), { method:"HEAD", cache:"no-store" });
      return r.ok;
    }catch{ return false; }
  }
  async function fetchNewest(){
      try{
          const url = bust(STATUS_URL);
          const r = await fetch(bust(STATUS_URL), {cache: "no-store"});
          if (!r.ok) {
            const txt = await rt.text().catch(()=>"(no body)");
            srvlog("status_rc", { rc: r.status, url });
            srvlog("status_body", { body: txt.slice(0,256) });
            return null;
          }
          return await r.json();
       }catch(e){
          srvlog("status_err", { err: String(e) });
	  return null;
      }
  }
  async function pollStatus(){
    if (DID_DONE) return;  // ignore any stray calls after finish  
    const data = await fetchNewest();
    // Fallback: if status is missing but the final page is already live, finish anyway
    if (!data){
      const FINAL_PGS = `https://soazcomms.github.io/analysis/${encodeURIComponent(label8)}/${encodeURIComponent(label8)}.analysis.html`;
      if (await headOK(FINAL_PGS)){
        DID_DONE = true;
        stopAllTimers();
        bar.style.width = "100%";
        const cb = Date.now();
        viewBtn.removeAttribute("disabled");
        viewBtn.href = FINAL_PGS + "?_cb=" + cb;
        statusEl.innerHTML = "‚úÖ Analysis complete.";
        const timersRow = document.getElementById("timersRow");
        if (timersRow) timersRow.style.display = "none";
      } else {
        statusEl.innerHTML = "‚è≥ Working‚Ä¶";
      }
      return;
    }
    srvlog("ui_phase", { phase: data.phase || "", status: data.status || "" });
    if (/error/i.test(data.phase || "")){
	stopAllTimers();
	statusEl.innerHTML = data.status || "‚ùå Failed.";
	bar.style.width = "100%";
	return;
    }
    // when status says publishing/done (server has pushed; Pages may lag)
    if (/publishing/i.test(data.phase || "")) {
	statusEl.innerHTML = "üöÄ Publishing results‚Ä¶";
	return; // keep polling; when Pages is live we'll fall through to 'done'
    }
    const isDone = (/done/i.test(data.phase||"")) || (/‚úÖ/u.test(data.status||""));
    if (!isDone){
      statusEl.innerHTML = data.status || "‚è≥ Running analysis‚Ä¶";
      return;
    }
    // DONE: only enable View when Pages has the HTML
    if (!(await headOK(FINAL_PGS))){  // headOK helper, or omit and just set href
	statusEl.innerHTML = "‚è≥ Waiting for GitHub Pages‚Ä¶";
	return;
    }

    // Pages is live: finish & enable View (never RAW)
    DID_DONE = true;          // mark final  
    stopAllTimers();
    bar.style.width = "100%";
    viewBtn.removeAttribute("disabled");
    const cb = (data && data.timestamp) ? data.timestamp : Date.now();
    viewBtn.href = FINAL_PGS + "?_cb=" + cb;  // bust CDN/browser cache  
    statusEl.innerHTML = data.status || "‚úÖ Analysis complete.";
    headerEl.textContent = headerEl.textContent + " ‚Äî DONE";
//    const timersRow = document.getElementById("timersRow");
//    if (timersRow) timersRow.style.display = "none";
  }

  /* ========== GO ========== */
  startJobOnce();

})();
</script>
</body>
</html>
