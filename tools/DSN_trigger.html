<!DOCTYPE html>
<html lang="en">
<head>
  <meta charset="UTF-8" />
  <title>üî¨ DSN Analysis</title>
  <meta name="viewport" content="width=device-width, initial-scale=1" />
  <meta http-equiv="Cache-Control" content="no-store, max-age=0" />
  <meta http-equiv="Pragma" content="no-cache" />
  <meta http-equiv="Expires" content="0" />
  <style>
    :root { --primary:#007bff; --accent:#87CEFA; --ok:#2e7d32; --warn:#c62828; --barbg:#edf2f7; }
    body { font-family: system-ui,-apple-system,Segoe UI,Roboto,sans-serif; text-align:center; margin:2rem; }
    h2 { margin-bottom:.25rem; }
    #headerText { margin:.25rem 0 .5rem; color:#444; }
    #status { margin:.5rem 0 .5rem; font-size:1.05rem; min-height:2.4em; }
    a.button { display:none; margin-top:.75rem; padding:.6rem 1.2rem; font-size:1rem; background:var(--primary); color:#fff; text-decoration:none; border-radius:8px; }
    .actions { margin-top:.75rem; display:flex; gap:.5rem; justify-content:center; flex-wrap:wrap; }
    button { padding:.55rem .95rem; font-size:.95rem; border:0; border-radius:8px; cursor:pointer; }
    #exit-btn { background:var(--accent); }
    #extend-btn { background:#e0e7ff; display:none; }
    .muted { color:#666; font-size:.9rem; }
    .progress-wrap { width:min(720px,90vw); margin:1rem auto .25rem; text-align:center; }
    .progress { width:50%; margin:0 auto; height:12px; background:var(--barbg); border-radius:999px; overflow:hidden; box-shadow:inset 0 0 0 1px #e2e8f0; }
    .legend { width:50%; margin:.35rem auto 0; display:flex; justify-content:space-between; font-size:.85rem; color:#555; }
    .bar { height:100%; width:0%; background:linear-gradient(90deg,#69c,#38bdf8 40%,#22c55e 75%,#16a34a 100%); transition:width .4s ease; }
    .bar.timeout { background:linear-gradient(90deg,#f59e0b,#ef4444); }
  </style>
</head>
<body>
  <h2 id="title">üî¨ DSN Analysis</h2>
  <div id="headerText" class="muted"></div>
  <div id="status">‚è≥ Initializing‚Ä¶</div>

  <div class="progress-wrap" aria-label="Progress toward timeout window">
    <div class="progress"><div id="bar" class="bar" role="progressbar" aria-valuemin="0" aria-valuemax="100" aria-valuenow="0"></div></div>
    <div class="legend"><span id="leg-left" class="muted">0:00</span><span id="leg-right" class="muted">Timeout in 7:00</span></div>
  </div>

  <a id="open-link" class="button" target="_blank" rel="noopener">üìÑ View Analysis Result</a>

  <div class="actions">
    <button id="extend-btn" type="button">‚è±Ô∏è Keep waiting 5 more min</button>
    <button id="exit-btn"   type="button">üîô Exit</button>
  </div>

  <!-- Optional: sets window.DEBUG_FLAG for lightweight logging if you want -->
  <script src="https://sound-kangaroo-unlikely.ngrok-free.app/env.js"></script>

<script>
(() => {
  // ========= Constants & params =========
  const GH_PAGES_BASE = "https://soazcomms.github.io/";
  const STATUS_DIR    = "status";

  const qs    = new URLSearchParams(location.search);
  const label = (qs.get("label")||"").trim();
  const fromQ = (qs.get("from") || "").trim();
  const toQ   = (qs.get("to")   || "").trim();

  // We accept YYYY-MM-DD or ISO and pass through unchanged
  const fromISO = fromQ;
  const toISO   = toQ;

  const DEFAULT_WEBHOOK = "https://sound-kangaroo-unlikely.ngrok-free.app";
  const WEBHOOK_ORIG = (qs.get("webhook") || DEFAULT_WEBHOOK).replace(/\/+$/,"");
  const WEBHOOK_MAIN = WEBHOOK_ORIG + "/webhook";      // preferred analysis endpoint
  const WEBHOOK_FALL = WEBHOOK_ORIG + "/DSN_trigger";  // legacy fallback
  const DEBUG_URL    = WEBHOOK_ORIG + "/DSN_debug";    // ultra-light pixel logger

  // ========= UI handles =========
  const titleEl  = document.getElementById("title");
  const headerEl = document.getElementById("headerText");
  const statusEl = document.getElementById("status");
  const linkEl   = document.getElementById("open-link");
  const barEl    = document.getElementById("bar");
  const legL     = document.getElementById("leg-left");
  const legR     = document.getElementById("leg-right");
  const extendBtn= document.getElementById("extend-btn");
  const exitBtn  = document.getElementById("exit-btn");

  function onlyDate(s){ return (s||"").split("T")[0]; }
  if (label) titleEl.textContent = `üî¨ DSN Analysis v4 ‚Äî ${label}`;
  if (label && fromISO && toISO) headerEl.textContent =
  `Label: ${label} ¬∑ Range: ${onlyDate(fromISO)} ‚Üí ${onlyDate(toISO)}`;
  // ========= Progress / timing =========
  const POLL_MS       = 5000;
  const TIMEOUT_INIT  = 7 * 60_000;
  const EXTEND_MS     = 5 * 60_000;
  const RUN_ID        = "run-" + Date.now().toString(36);

  let extraTime = 0;
  const start   = Date.now();

  function mmss(ms){ const s=Math.max(0,Math.floor(ms/1000)); return `${Math.floor(s/60)}:${String(s%60).padStart(2,"0")}`; }
  function updateProgress(timedOut){
    const elapsed = Date.now()-start;
    const total   = TIMEOUT_INIT + extraTime;
    const pct     = Math.max(3, Math.min(100, Math.floor(elapsed/total*100)));
    barEl.style.width = pct + "%";
    barEl.classList.toggle("timeout", !!timedOut);
    legL.textContent = mmss(elapsed);
    legR.textContent = timedOut ? "Waiting‚Ä¶" : `Timeout in ${mmss(Math.max(0,total-elapsed))}`;
  }

  extendBtn.addEventListener("click", () => {
    extraTime += EXTEND_MS;
    extendBtn.style.display = "none";
    statusEl.innerHTML = "‚è≥ Extended‚Ä¶ still working.";
    debug("manual_extend", `+${Math.round(EXTEND_MS/60000)}m`);
  });

  exitBtn.addEventListener("click", () => window.close());

  // ========= ultra-light ‚Äúpixel‚Äù logger =========
  const DEBUG = !!window.DEBUG_FLAG;
  function debug(step, note) {
    if (!DEBUG) return;
    try {
      const payload = {step, note: String(note||""), label, from: fromISO, to: toISO, run_id: RUN_ID, t: Date.now()};
      if (navigator.sendBeacon) {
        const blob = new Blob([JSON.stringify(payload)], {type:"application/json"});
        navigator.sendBeacon(DEBUG_URL, blob);
      } else {
        const img = new Image(1,1);
        img.src = DEBUG_URL + "?" + new URLSearchParams(payload).toString();
      }
    } catch(_) {}
  }

  // ========= Helpers =========
  function safeShort(lbl){ return (lbl||"").split("_")[0].replace(/[^\w.\-]/g,"_"); } // DSN019-S_MtLemmon -> DSN019-S
  function safeFull(lbl){  return (lbl||"").replace(/[^\w.\-]/g,"_"); }
  function bust(u){ return u + (u.includes("?")?"&":"?") + "bust=" + Date.now(); }

  function statusUrls(){
    const sFull  = safeFull(label);
    const sShort = safeShort(label);
    return [
      `${GH_PAGES_BASE}${STATUS_DIR}/status-${sFull}.json`,
      `${GH_PAGES_BASE}${STATUS_DIR}/status-${sShort}.json`,
    ].map(bust);
  }

  function resolveUrl(relOrAbs){
    return /^https?:\/\//i.test(relOrAbs) ? relOrAbs : (GH_PAGES_BASE + String(relOrAbs).replace(/^\/+/, ""));
  }

  // Minimal ngrok preflight (pixel GET, then /health GET)
  function pingPixel(url, timeoutMs=3000){
    return new Promise(res => {
      let done=false; const img=new Image();
      const to=setTimeout(()=>{ if(!done){ done=true; img.src=""; res(false); } }, timeoutMs);
      img.onload=()=>{ if(!done){ done=true; clearTimeout(to); res(true); } };
      img.onerror=()=>{ if(!done){ done=true; clearTimeout(to); res(false); } };
      img.referrerPolicy="no-referrer";
      img.src=url + (url.includes("?")?"&":"?") + "ts=" + Date.now();
    });
  }
  async function preflightNgrok(){
    debug("preflight_begin", WEBHOOK_ORIG);
    const ok1 = await pingPixel(DEBUG_URL);
    if (ok1) return true;
    try {
      const ctrl = new AbortController(); const t=setTimeout(()=>ctrl.abort(),4000);
      const r = await fetch(WEBHOOK_ORIG + "/health", {signal:ctrl.signal, cache:"no-store"});
      clearTimeout(t);
      return r.ok;
    } catch { return false; }
  }

  // ========= NEW: fetch both statuses and choose the newest =========
  async function fetchStatuses() {
    const urls = statusUrls();
    const results = [];
    await Promise.all(urls.map(async (u) => {
      try {
        const r = await fetch(u, {cache:"no-store"});
        if (!r.ok) return;
        const j = await r.json();
        const ts = Number(j.timestamp)||0;
        const hasHtml = !!(j.html && String(j.html).trim());
        const isCsvOnly = !!(j.csv) && !hasHtml;
        results.push({url:u, data:j, ts, hasHtml, isCsvOnly});
      } catch(_) {}
    }));
    if (!results.length) return null;

  // Sort newest first, but prefer results with HTML over csv-only at same/close timestamp
    results.sort((a,b) => {
      if (a.hasHtml !== b.hasHtml) return b.hasHtml - a.hasHtml; // html first
      return b.ts - a.ts; // newest first
    });
    return results[0];
  }
  // ========= Poll using newest status only =========
  async function pollOnce(){
    try {
      const newest = await fetchStatuses();
      if (!newest) return {done:false};

      const data = newest.data;

      if (data.phase === "error"){
        statusEl.innerHTML = (data.status || "‚ùå Analysis failed.") +
          (data.note ? `<pre style="text-align:left;white-space:pre-wrap">${data.note}</pre>` : "");
        debug("server_error_latest", newest.url);
        document.title = "‚ùå DSN Analysis";
        return {done:true};
      }

      // success path ‚Äî explicit html OR inferred index.html
      const htmlRel = (data.html && String(data.html).trim()) || "";
      const finalUrl = resolveUrl(htmlRel || `analysis/${safeShort(label)}/index.html`);

      if (htmlRel) {
        linkEl.href = finalUrl;
        linkEl.style.display = "inline-block";
        statusEl.innerHTML = data.status || "‚úÖ Analysis complete.";
        document.title = "‚úÖ DSN Analysis";
        barEl.style.width = "100%";
        debug("html_ready", finalUrl);
        return {done:true};
      }

      // no html in JSON: probe inferred index.html
      try {
        const head = await fetch(finalUrl, {method:"HEAD", cache:"no-store"});
        if (head.ok){
          linkEl.href = finalUrl;
          linkEl.style.display = "inline-block";
          statusEl.innerHTML = data.status || "‚úÖ Analysis complete.";
          document.title = "‚úÖ DSN Analysis";
          barEl.style.width = "100%";
          debug("html_ready_inferred", finalUrl);
          return {done:true};
        }
      } catch(_) {}

      // keep waiting
      statusEl.innerHTML = "‚è≥ Generating plots‚Ä¶";
      return {done:false};
    } catch (e){
      debug("poll_exception", String(e));
      return {done:false};
    }
  }

  // ========= Main =========
  (async function main(){
    if (!label || !fromISO || !toISO){
      statusEl.innerHTML = "‚ùå Missing/invalid label/from/to (need YYYY-MM-DD).";
      return;
    }

    statusEl.innerHTML = `üîÑ Running analysis for <b>${label}</b>‚Ä¶<br/>‚è≥ Generating plots‚Ä¶`;

    const ok = await preflightNgrok();
    if (!ok){
      statusEl.innerHTML = `‚ùå ngrok unreachable at <code>${WEBHOOK_ORIG}</code><br/><span class="muted">Run your tunnel and reload.</span>`;
      barEl.style.width = "0%";
      document.title = "‚ùå DSN Analysis";
      return;
    }

    // start job (fire and poll)
    try {
      const body = { label, from: fromISO, to: toISO };
      let lastErr = null;
      for (const url of [WEBHOOK_MAIN, WEBHOOK_FALL]){
        try {
          const r = await fetch(url, { method:"POST", headers:{"Content-Type":"application/json"}, body: JSON.stringify(body) });
          if (r.ok) break;
          lastErr = new Error("HTTP "+r.status+" @ "+url);
        } catch(e){ lastErr = e; }
      }
      if (lastErr) debug("post_job_warn", String(lastErr));
    } catch(e){
      statusEl.textContent = "‚è≥ Processing‚Ä¶ (webhook may be delayed)";
      debug("post_job_fail", String(e));
    }

    let done=false;
    while (!done){
      const elapsed = Date.now()-start;
      const timedOut = elapsed >= (TIMEOUT_INIT + extraTime);
      updateProgress(timedOut);
      if (timedOut){
        statusEl.innerHTML = "‚è±Ô∏è Still working‚Ä¶ might be a larger data window.";
        extendBtn.style.display = "inline-block";
      }
      const r = await pollOnce();
      done = !!r.done;
      if (!done) await new Promise(r => setTimeout(r, POLL_MS));
    }
  })();
})();
</script>
</body>
</html>
