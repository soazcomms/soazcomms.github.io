<!DOCTYPE html>
<html lang="en">
<head>
  <!-- Google tag (gtag.js) -->
  <script async src="https://www.googletagmanager.com/gtag/js?id=G-0PQTHF10EQ"></script>
  <script>window.dataLayer=window.dataLayer||[];function gtag(){dataLayer.push(arguments);} gtag('js', new Date()); gtag('config','G-0PQTHF10EQ');</script>
  <meta charset="UTF-8" />
  <title>üî¨ DSN Analysis</title>
  <meta name="viewport" content="width=device-width, initial-scale=1" />
  <meta http-equiv="Cache-Control" content="no-store, max-age=0" />
  <meta http-equiv="Pragma" content="no-cache" />
  <meta http-equiv="Expires" content="0" />
  <style>
    :root { --primary:#007bff; --accent:#87CEFA; --ok:#2e7d32; --warn:#c62828; --barbg:#edf2f7; }
    body { font-family: system-ui,-apple-system,Segoe UI,Roboto,sans-serif; text-align:center; margin:2rem; }
    h2 { margin-bottom:.25rem; }
    #status { margin:.5rem 0 .5rem; font-size:1.05rem; min-height:2.4em; }
    a.button { display:none; margin-top:.75rem; padding:.6rem 1.2rem; font-size:1rem; background:var(--primary); color:#fff; text-decoration:none; border-radius:8px; }
    .actions { margin-top:.75rem; display:flex; gap:.5rem; justify-content:center; flex-wrap:wrap; }
    button { padding:.55rem .95rem; font-size:.95rem; border:0; border-radius:8px; cursor:pointer; }
    #exit-btn { background:var(--accent); }
    #extend-btn { background:#e0e7ff; }
    .muted { color:#666; font-size:.9rem; }
    .progress-wrap { width:min(720px,90vw); margin:1rem auto .25rem; text-align:center; }
    .progress { width:50%; margin:0 auto; height:12px; background:var(--barbg); border-radius:999px; overflow:hidden; box-shadow:inset 0 0 0 1px #e2e8f0; }
    .legend { width:50%; margin:.35rem auto 0; display:flex; justify-content:space-between; font-size:.85rem; color:#555; }
    .bar { height:100%; width:0%; background:linear-gradient(90deg,#69c,#38bdf8 40%,#22c55e 75%,#16a34a 100%); transition:width .4s ease; }
    .bar.timeout { background:linear-gradient(90deg,#f59e0b,#ef4444); }
  </style>
</head>
<body>
  <h2 id="title">üî¨ DSN Analysis</h2>
  <div id="status">‚è≥ Initializing‚Ä¶</div>

  <div class="progress-wrap" aria-label="Progress toward timeout window">
    <div class="progress"><div id="bar" class="bar" role="progressbar" aria-valuemin="0" aria-valuemax="100" aria-valuenow="0"></div></div>
    <div class="legend"><span id="leg-left" class="muted">0:00</span><span id="leg-right" class="muted">Timeout in 7:00</span></div>
  </div>

  <a id="open-link" class="button" target="_blank" rel="noopener">üìÑ View Analysis Result</a>

  <div class="actions">
    <button id="extend-btn" type="button" style="display:none;">‚è±Ô∏è Keep waiting 5 more min</button>
    <button id="exit-btn"   type="button">üîô Exit</button>
  </div>

<script>
  const GH_PAGES_BASE = "https://soazcomms.github.io/";
  const STATUS_DIR    = "status";

  const qs    = new URLSearchParams(location.search);
  const label = (qs.get("label")||"").trim();
  const from  = (qs.get("from") || "").trim();
  const to    = (qs.get("to")   || "").trim();
  function toISOstr(s){ if(!s) return ""; try { return new Date(s).toISOString(); } catch { return ""; } }
  const fromISO = toISOstr(from);
  const toISO   = toISOstr(to);

  // **** REQUIRED: ngrok must be up (HTTPS) ****
  // Allow override via ?webhook=https://<host>
  const DEFAULT_WEBHOOK = "https://sound-kangaroo-unlikely.ngrok-free.app";
  const WEBHOOK_ORIG  = (qs.get("webhook") || DEFAULT_WEBHOOK).replace(/\/+$/,"");
  const WEBHOOK_URL   = WEBHOOK_ORIG + "/DSN_webhook";
  const TURD_URL      = WEBHOOK_ORIG + "/DSN_turd";

  const POLL_INTERVAL_MS = 10_000;
  const TIMEOUT_MS_INIT  = 7 * 60_000;
  const EXTEND_MS        = 7 * 60_000;

  const DEBUG_TURD = true;
  const RUN_ID     = "run-" + Date.now() + "-" + Math.random().toString(36).slice(2,8);

  // ---- bullet-proof turd: always tries a GET pixel and a JSON POST so logs appear even if CORS blocks fetch
  function turd(step, note) {
    if (!DEBUG_TURD) return;
    const payload = {
      step: step, note: String(note||""), where:"HTML",
      run_id: RUN_ID, ts: String(Date.now()),
      label, from: fromISO, to: toISO, webhook: WEBHOOK_ORIG
    };
    // Pixel GET (works without CORS)
    try { (new Image()).src = TURD_URL + "?" + new URLSearchParams(payload).toString(); } catch(_) {}
    // Best-effort JSON POST (server handler should accept JSON too)
    try {
      fetch(TURD_URL, { method:"POST", mode:"no-cors",
        headers:{"Content-Type":"application/json"},
        body: JSON.stringify(payload)
      });
    } catch(_) {}
  }

  // Global traps -> always logged
  window.addEventListener("error", e => turd("window_error", (e && e.message) || "err"));
  window.addEventListener("unhandledrejection", e => turd("unhandled_rejection", (e && (e.reason && e.reason.message)) || "rej"));

  turd("page_load", location.search || "(no query)");

  const titleEl  = document.getElementById("title");
  const statusEl = document.getElementById("status");
  const linkEl   = document.getElementById("open-link");
  const barEl    = document.getElementById("bar");
  const legL     = document.getElementById("leg-left");
  const legR     = document.getElementById("leg-right");
  const extendBtn= document.getElementById("extend-btn");
  const exitBtn  = document.getElementById("exit-btn");
  if (label) titleEl.textContent = `üî¨ DSN Analysis ‚Äî ${label}`;

  const jobStart = Date.now();
  let timeoutMs  = TIMEOUT_MS_INIT, extraTime=0, lastStamp=0, lastNote="", lastStatus="";

  function mmss(ms){ const s=Math.max(0,Math.floor(ms/1000)); return `${Math.floor(s/60)}:${String(s%60).padStart(2,"0")}`; }
  function updateProgress(timedOut){
    const elapsed = Date.now()-jobStart, total=timeoutMs+extraTime;
    const pct = Math.max(3, Math.min(100, Math.floor(elapsed/total*100)));
    barEl.style.width = pct+"%";
    if (timedOut) barEl.classList.add("timeout"); else barEl.classList.remove("timeout");
    legL.textContent = mmss(elapsed);
    legR.textContent = timedOut ? "Waiting‚Ä¶" : `Timeout in ${mmss(Math.max(0,total-elapsed))}`;
  }
  function softExtend(ms, why){ extraTime += ms; turd("auto_extend", `${why} +${Math.round(ms/60000)}m`); }
  extendBtn.addEventListener("click", ()=>{ extraTime+=EXTEND_MS; extendBtn.style.display="none"; statusEl.innerHTML="‚è≥ Extended‚Ä¶ still working."; turd("manual_extend", `+${Math.round(EXTEND_MS/60000)}m`); });
  exitBtn.addEventListener("click", ()=>{ window.close(); });

  function statusUrls(){
    const safeFull  = (label||"").replace(/[^\w.\-]+/g,"_");
    const shortPart = (label||"").split("_")[0];
    const safeShort = (shortPart||"").replace(/[^\w.\-]+/g,"_");
    const bust = `?bust=${Date.now()}`;
    return [
      `${GH_PAGES_BASE}${STATUS_DIR}/status-${safeFull}.json${bust}`,
      `${GH_PAGES_BASE}${STATUS_DIR}/status-${safeShort}.json${bust}`
    ];
  }
  function resolveResultUrl(relOrAbs){ return /^https?:\/\//i.test(relOrAbs) ? relOrAbs : `${GH_PAGES_BASE}${String(relOrAbs).replace(/^\/+/,"")}`; }

  // ===== PRE-FLIGHT: prove ngrok reachable even if fetch/CORS is blocked =====
  function pingPixel(url, timeoutMs=4000){
    return new Promise(res=>{
      let done=false; const img=new Image();
      const to=setTimeout(()=>{ if(!done){ done=true; img.src=""; res(false); } }, timeoutMs);
      img.onload=()=>{ if(!done){ done=true; clearTimeout(to); res(true); } };
      img.onerror=()=>{ if(!done){ done=true; clearTimeout(to); res(false); } };
      img.referrerPolicy="no-referrer";
      img.src=url + (url.includes("?")?"&":"?") + "ts=" + Date.now();
    });
  }
  async function preflightNgrok(){
    turd("preflight_begin", WEBHOOK_ORIG);

    const ok1 = await pingPixel(TURD_URL + "?step=preflight_pixel&where=HTML&run_id="+encodeURIComponent(RUN_ID));
    if (ok1) { turd("preflight_ok_pixel","1x1 ok"); return true; }

    try {
      await fetch(TURD_URL, { method:"POST", mode:"no-cors",
        headers:{"Content-Type":"application/json"},
        body: JSON.stringify({step:"preflight_post", where:"HTML", run_id:RUN_ID, webhook:WEBHOOK_ORIG})
      });
      turd("preflight_post_sent","no-cors");
    } catch(e){ turd("preflight_post_err", String(e)); }

    try {
      const ctrl = new AbortController(); const t=setTimeout(()=>ctrl.abort(),5000);
      const r = await fetch(WEBHOOK_ORIG + "/health", { method:"GET", cache:"no-store", signal:ctrl.signal });
      clearTimeout(t);
      if (r.ok) { turd("preflight_ok_health","HTTP "+r.status); return true; }
      turd("preflight_fail_health","HTTP "+r.status); return false;
    } catch(e){ turd("preflight_fail_health",(e&&e.message)||"health_err"); return false; }
  }
  // ==========================================================================

  // ---- NEW: explicit pollStatus with error abort & logging ----
  async function pollStatusOnce() {
    try {
      let data=null, okUrl=null;
      for (const u of statusUrls()) {
        const r = await fetch(u, {cache:"no-store"});
        if (r.ok) { data = await r.json(); okUrl=u; break; }
      }
      if (!data) {
        turd("status_http","both JSON 404");
        return {done:false};
      }

      // Extend on movement
      if ((data.timestamp||0)>lastStamp){ lastStamp=data.timestamp; softExtend(120000,"status timestamp advanced"); }
      if ((data.note||"")!==lastNote){ lastNote=data.note||""; softExtend(60000,"note changed"); }
      if ((data.status||"")!==lastStatus){ lastStatus=data.status||""; softExtend(60000,"status changed"); }

      // Abort path: phase === "error"
      if ((data.phase||"") === "error") {
        const msg = (data.status || "‚ùå Analysis failed.") + (data.note ? `<pre style="text-align:left;white-space:pre-wrap">${data.note}</pre>` : "");
        statusEl.innerHTML = msg;
        barEl.classList.add("timeout");
        legR.textContent = "Error";
        turd("analysis_fail", (data.note||"no-note") + " via "+ (okUrl||""));
        document.title = "‚ùå DSN Analysis";
        return {done:true}; // stop polling
      }

      // Success path
      if (data.status && data.html && (data.timestamp||0) >= jobStart) {
        statusEl.innerHTML = data.status;
        linkEl.href = resolveResultUrl(data.html);
        linkEl.style.display = "inline-block";
        barEl.style.width = "100%"; barEl.classList.remove("timeout"); legR.textContent = "Complete";
        turd("html_ready", (okUrl||"")+" ‚Üí "+data.html);
        document.title = "‚úÖ DSN Analysis";
        return {done:true};
      }

      // Still running
      statusEl.innerHTML = `‚è≥ Generating plots‚Ä¶`;
      return {done:false};

    } catch (e) {
      turd("status_fetch_fail", String(e));
      return {done:false};
    }
  }

  (async function main(){
    statusEl.innerHTML = label
      ? `üîÑ Running DSN analysis for <b>${label}</b><br/>‚è≥ Generating plots‚Ä¶`
      : `üîÑ Running DSN analysis‚Ä¶<br/>‚è≥ Generating plots‚Ä¶`;

    const ok = await preflightNgrok();
    if (!ok) {
      statusEl.innerHTML = `‚ùå ngrok unreachable at <code>${WEBHOOK_ORIG}</code><br/><span class="muted">Run <b>GoWebhook</b> and reload. Or pass ?webhook=https://your-ngrok</span>`;
      document.title = "‚ùå DSN Analysis";
      barEl.style.width = "0%";
      return;
    }

    // POST job
    try {
      turd("post_job", JSON.stringify({label, from:fromISO, to:toISO, webhook:WEBHOOK_ORIG}));
      // ‚úÖ Ensure correct target for webhook
      const base   = (WEBHOOK_ORIG || "").trim();
      const jobUrl = base.replace(/\/+$/,'') + "/webhook";

      const res = await fetch(jobUrl, {
        method:"POST",
        headers: { "Content-Type": "application/json" },
        body: JSON.stringify({ label, from:fromISO, to:toISO })
      });
      if (!res.ok) throw new Error(`Webhook HTTP ${res.status}`);
      turd("post_job_ok");
    } catch (e) {
      statusEl.textContent = "‚è≥ Processing‚Ä¶ (webhook may be delayed)";
      turd("post_job_fail", String(e));
    }

    // Poll with explicit loop + progress updates
    let done=false;
    while (!done) {
      const elapsed = Date.now()-jobStart, total=timeoutMs+extraTime, timedOut = elapsed>=total;
      updateProgress(timedOut);
      if (timedOut) { statusEl.innerHTML="‚è±Ô∏è Still working‚Ä¶ might be a larger data window.<br/><span class='muted'>You can keep waiting.</span>"; extendBtn.style.display="inline-block"; turd("timeout_window_hit"); }
      const r = await pollStatusOnce();
      done = !!r.done;
      if (!done) { await new Promise(r=>setTimeout(r, POLL_INTERVAL_MS)); }
    }
  })();
</script>
</body>
</html>
